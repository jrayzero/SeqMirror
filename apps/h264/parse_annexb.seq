from cola.bitseq import *
from parse_nal_units import *

# Annex B.1.1
# The FIRST NAL unit may contain leading zeros
def drop_leading_zeros(bits: Bits[64]):
  # start by looking for leading_zero_8bits
  while bits.peek(24) != u64(0x000001) and bits.peek(32) != u64(0x00000001):
    check_val(bits(8), u64(0x00), "leading_zero_8bits")

def byte_stream_nal_unit(bits: Bits[64]):
  if bits.peek(24) != u64(0x000001):
    check_val(bits(8), u64(0x0), "zero_byte")
  check_val(bits(24), u64(0x000001), "start_code_prefix_one_3bytes")
  # infer the number of bytes in the nalunit by reading all the data
  nal_bits = Bits[64]()
  while True:
    if not bits.bits_left():
      break
    b = bits.peek(24)
    if b == u64(0x000000) or b == u64(0x000001):
      break
    else:
      nal_bits.pack(bits(8),8)
  NumBytesInNALUnit = len(nal_bits) // 8
  cola_debug(NumBytesInNALUnit)  
  # remove any trailing zeros
  while bits.bits_left() and bits.peek(24) != u64(0x000001) and bits.peek(32) != u64(0x00000001):
    check_val(bits(8), u64(0), "trailing_sero_8bits")
  return nal_bits

