from cola.bitseq import *
from video import *
from golomb import *
import math

@extend
class SeqParameterSet:

  def __init__(self):
    self.profile_idc = 0
    self.constraint_set0_flag = False
    self.constraint_set1_flag = False
    self.constraint_set2_flag = False
    self.constraint_set3_flag = False
    self.constraint_set4_flag = False
    self.constraint_set5_flag = False
    self.level_idc = 0
    self.seq_parameter_set_id = 0
    self.chroma_format_idc = 0
    self.separate_colour_plane_flag = False
    self.bit_depth_luma_minus8 = 0
    self.bit_depth_chroma_minus8 = 0
    self.qpprime_y_zero_transform_bypass_flag = False
    self.seq_scaling_matrix_present_flag = False
 #   self.seq_scaling_list_present_flag = Array[bool]()    
    # not using block here because these are arrays of different sizes (so not a block shape)
    #    self.scaling_list = SeqParameterSet.make_default_scaling_lists()
    self.log2_max_frame_num_minus4 = 0
    self.pic_order_cnt_type = 0
    self.log2_max_pic_order_cnt_lsb_minus4 = 0
    self.delta_pic_order_always_zero_flag = False
    self.offset_for_non_ref_pic = 0
    self.offset_for_top_to_bottom_field = 0
    self.num_ref_frames_in_pic_order_cnt_cycle = 0
#    self.offset_for_ref_frame = Array[int]()
    self.max_num_ref_frames = 0
    self.gaps_in_frame_num_value_allowed_flag = False
    self.pic_width_in_mbs_minus1 = 0
    self.pic_height_in_map_units_minus1 = 0
    self.frame_mbs_only_flag = False
    self.mb_adaptive_frame_field_flag = False
    self.direct_8x8_inference_flag = False
    self.frame_cropping_flag = False
    self.frame_crop_left_offset = 0
    self.frame_crop_right_offset = 0
    self.frame_crop_top_offset = 0
    self.frame_crop_bottom_offset = 0
    self.vui_parameters_present_flag = False


#  def make_default_scaling_lists():
#    scaling_list = Array[Array[int]](12)
#    default_4x4_intra = [6,13,13,20,20,20,28,28,28,28,32,32,32,37,37,42]
#    default_4x4_inter = [10,14,14,20,20,20,24,24,24,24,27,27,27,30,30,34]
#    default_8x8_intra = [6,10,10,13,11,13,16,16,16,16,18,18,18,18,18,23,23,23,23,23,23,25,25,25,25,25,25,25,27,27,27,27,27,27,27,27,29,29,29,29,29,29,29,31,31,31,31,31,31,33,33,33,33,33,36,36,36,36,38,38,38,40,40,42]
#    default_8x8_inter = [9,13,13,15,13,15,17,17,17,17,19,19,19,19,19,21,21,21,21,21,21,22,22,22,22,22,22,22,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,27,27,27,27,27,27,28,28,28,28,28,30,30,30,30,32,32,32,33,33,35]
#    scaling_list[0] = default_4x4_intra
#    scaling_list[1] = default_4x4_intra
#    scaling_list[2] = default_4x4_intra
#    scaling_list[3] = default_4x4_inter
#    scaling_list[4] = default_4x4_inter
#    scaling_list[5] = default_4x4_inter
#    scaling_list[6] = default_8x8_intra
#    scaling_list[7] = default_8x8_inter
#    scaling_list[8] = default_8x8_intra
#    scaling_list[9] = default_8x8_inter
#    scaling_list[10] = default_8x8_intra
#    scaling_list[11] = default_8x8_inter
#    return scaling_list

  def dump(self):
    # TODO have a compiler function that lets you print all the fields of an object (shove in IR pass)
    cola_debug(self.profile_idc)
    cola_debug(self.constraint_set0_flag)
    cola_debug(self.constraint_set1_flag)
    cola_debug(self.constraint_set2_flag)
    cola_debug(self.constraint_set3_flag)
    cola_debug(self.constraint_set4_flag)
    cola_debug(self.constraint_set5_flag)
    cola_debug(self.level_idc)
    cola_debug(self.seq_parameter_set_id)
    cola_debug(self.chroma_format_idc)
    cola_debug(self.separate_colour_plane_flag)
    cola_debug(self.bit_depth_luma_minus8)
    cola_debug(self.bit_depth_chroma_minus8)
    cola_debug(self.qpprime_y_zero_transform_bypass_flag)
    cola_debug(self.seq_scaling_matrix_present_flag)
    cola_debug(self.seq_scaling_list_present_flag)
    cola_debug(self.log2_max_frame_num_minus4)
    cola_debug(self.pic_order_cnt_type)
    cola_debug(self.log2_max_pic_order_cnt_lsb_minus4)
    cola_debug(self.delta_pic_order_always_zero_flag)
    cola_debug(self.offset_for_non_ref_pic)
    cola_debug(self.offset_for_top_to_bottom_field)
    cola_debug(self.num_ref_frames_in_pic_order_cnt_cycle)
    cola_debug(self.offset_for_ref_frame)
    cola_debug(self.max_num_ref_frames)
    cola_debug(self.gaps_in_frame_num_value_allowed_flag)
    cola_debug(self.pic_width_in_mbs_minus1)
    cola_debug(self.pic_height_in_map_units_minus1)
    cola_debug(self.frame_mbs_only_flag)
    cola_debug(self.mb_adaptive_frame_field_flag)
    cola_debug(self.direct_8x8_inference_flag)
    cola_debug(self.frame_cropping_flag)
    cola_debug(self.frame_crop_left_offset)
    cola_debug(self.frame_crop_right_offset)
    cola_debug(self.frame_crop_top_offset)
    cola_debug(self.frame_crop_bottom_offset)
    cola_debug(self.vui_parameters_present_flag)
    
  def parse(self, nal_unit):
    self.seq_parameter_set_rbsp(nal_unit)

  # these names match the standard
  def seq_parameter_set_rbsp(self, nal_unit):
    self.seq_parameter_set_data(nal_unit)

  def seq_parameter_set_data(self, nal_unit):
    rbsp = nal_unit.rbsp_bytes
    self.profile_idc = int(rbsp(8))
    self.constraint_set0_flag = bool(rbsp(1))
    self.constraint_set1_flag = bool(rbsp(1))
    self.constraint_set2_flag = bool(rbsp(1))
    self.constraint_set3_flag = bool(rbsp(1))
    self.constraint_set4_flag = bool(rbsp(1))
    self.constraint_set5_flag = bool(rbsp(1))
    check_val(rbsp(2), u64(0), "reserved_zero_bits")
    self.level_idc = int(rbsp(8))
    self.seq_parameter_set_id = int(ExpGolomb.udecode(rbsp))
    if self.profile_idc == 100 or self.profile_idc == 110 \
       or self.profile_idc == 122 or self.profile_idc == 244 \
       or self.profile_idc == 44 or self.profile_idc == 83 \
       or self.profile_idc == 86 or self.profile_idc == 118 \
       or self.profile_idc == 128 or self.profile_idc == 138 \
       or self.profile_idc == 139 or self.profile_idc == 134 \
       or self.profile_idc == 135:
      self.chroma_format_idc = int(ExpGolomb.udecode(rbsp))
      if self.chroma_format_idc == 3:
        self.separate_colour_plane_flag = bool(rbsp(1))
      self.bit_depth_luma_minus8 = int(ExpGolomb.udecode(rbsp))
      self.bit_depth_chroma_minus8 = int(ExpGolomb.udecode(rbsp))
      self.qpprime_y_zero_transform_bypass_flag = bool(rbsp(1))
      self.seq_scaling_matrix_present_flag = bool(rbsp(1))
      if self.seq_scaling_matrix_present_flag:
        amt = 8 if self.chroma_format_idc != 3 else 12
        self.seq_scaling_list_present_flag = Array[bool](amt)
        for i in range(amt):
          b = bool(rbsp(1))
          self.seq_scaling_list_present_flag[i] = b
          raise NotImplementedError()
    self.log2_max_frame_num_minus4 = int(ExpGolomb.udecode(rbsp))
    self.pic_order_cnt_type = int(ExpGolomb.udecode(rbsp))
    if self.pic_order_cnt_type == 0:
      self.log2_max_pic_order_cnt_lsb_minus4 = int(ExpGolomb.udecode(rbsp))
    elif self.pic_order_cnt_type == 1:
      self.delta_pic_order_always_zero_flag = bool(rbsp(1))
      self.offset_for_non_ref_pic = ExpGolomb.sdecode(rbsp)
      self.offset_for_top_to_bottom_field = ExpGolomb.sdecode(rbsp)
      self.num_ref_frames_in_pic_order_cnt_cycle = int(ExpGolomb.udecode(rbsp))
      self.offset_for_ref_frame = Array[int](self.num_ref_frames_in_pic_order_cnt_cycle)
      for i in range(self.num_ref_frames_in_pic_order_cnt_cycle):
        self.offset_for_ref_frame[i] = ExpGolomb.sdecode(rbsp)
    self.max_num_ref_frames = int(ExpGolomb.udecode(rbsp))
    self.gaps_in_frame_num_value_allowed_flag = bool(rbsp(1))
    self.pic_width_in_mbs_minus1 = int(ExpGolomb.udecode(rbsp))
    self.pic_height_in_map_units_minus1 = int(ExpGolomb.udecode(rbsp))
    self.frame_mbs_only_flag = bool(rbsp(1))
    if not self.frame_mbs_only_flag:
      self.mb_adaptive_frame_field_flag = bool(rbsp(1))
    self.direct_8x8_inference_flag = bool(rbsp(1))
    self.frame_cropping_flag = bool(rbsp(1))
    if self.frame_cropping_flag:
      self.frame_crop_left_offset = int(ExpGolomb.udecode(rbsp))
      self.frame_crop_right_offset = int(ExpGolomb.udecode(rbsp))
      self.frame_crop_top_offset = int(ExpGolomb.udecode(rbsp))
      self.frame_crop_bottom_offset = int(ExpGolomb.udecode(rbsp))
    self.vui_parameters_present_flag = bool(rbsp(1))
    if self.vui_parameters_present_flag:
      raise NotImplementedError()

@extend
class PicParameterSet:

  def __init__(self):
    pic_parameter_set_id = 0
    seq_parameter_set_id = 0
    entropy_coding_mode_flag = False
    bottom_field_pic_order_in_frame_present_flag = False
    num_slice_groups_minus1 = 0
    slice_group_map_type = 0
    slice_group_change_direction_flag = False
    slice_group_change_rate_minus1 = 0
    pic_size_in_map_units_minus1 = 0
    num_ref_idx_l0_default_active_minus1 = 0
    num_ref_idx_l1_default_active_minus1 = 0
    weighted_pred_flag = False
    weighted_bipred_idc = 0
    pic_init_qp_minus26 = 0
    pic_init_qs_minus26 = 0
    chroma_qp_index_offset = 0
    deblocking_filter_control_present_flag = False
    constrained_intra_pred_flag = False
    redundant_pic_cnt_present_flag = False
    transform_8x8_mode_flag = False
    pic_scaling_matrix_present_flag = False
    second_chroma_qp_index_offset = 0

  def dump(self):
    cola_debug(self.pic_parameter_set_id)
    cola_debug(self.seq_parameter_set_id)
    cola_debug(self.entropy_coding_mode_flag)
    cola_debug(self.bottom_field_pic_order_in_frame_present_flag)
    cola_debug(self.num_slice_groups_minus1)
    cola_debug(self.slice_group_map_type)
    cola_debug(self.run_length_minus1)
    cola_debug(self.top_left)
    cola_debug(self.bottom_right)
    cola_debug(self.slice_group_change_direction_flag)
    cola_debug(self.slice_group_change_rate_minus1)
    cola_debug(self.pic_size_in_map_units_minus1)
    cola_debug(self.slice_group_id)
    cola_debug(self.num_ref_idx_l0_default_active_minus1)
    cola_debug(self.num_ref_idx_l1_default_active_minus1)
    cola_debug(self.weighted_pred_flag)
    cola_debug(self.weighted_bipred_idc)
    cola_debug(self.pic_init_qp_minus26)
    cola_debug(self.pic_init_qs_minus26)
    cola_debug(self.chroma_qp_index_offset)
    cola_debug(self.deblocking_filter_control_present_flag)
    cola_debug(self.constrained_intra_pred_flag)
    cola_debug(self.redundant_pic_cnt_present_flag)
    cola_debug(self.transform_8x8_mode_flag)
    cola_debug(self.pic_scaling_matrix_present_flag)
    cola_debug(self.pic_scaling_list_present_flag)
    cola_debug(self.second_chroma_qp_index_offset)
    
  def parse(self, nal_unit, video: Video):
    self.pic_parameter_set_rbsp(nal_unit, video)

  def pic_parameter_set_rbsp(self, nal_unit, video):
    rbsp = nal_unit.rbsp_bytes
    self.pic_parameter_set_id = int(ExpGolomb.udecode(rbsp))
    self.seq_parameter_set_id = int(ExpGolomb.udecode(rbsp))
    self.entropy_coding_mode_flag = bool(rbsp(1))
    self.bottom_field_pic_order_in_frame_present_flag = bool(rbsp(1))
    self.num_slice_groups_minus1 = int(ExpGolomb.udecode(rbsp))
    if self.num_slice_groups_minus1 > 0:
      self.slice_group_map_type = int(ExpGolomb.udecode(rbsp))
      if self.slice_group_map_type == 0:
        self.run_length_minus1 = Array[int](self.num_slice_groups_minus1)
        for i in range(self.num_slice_groups_minus1):
          self.run_length_minus1[i] = int(ExpGolomb.udecode(rbsp))
      elif self.slice_group_map_type == 2:
        self.top_left = Array[int](self.num_slice_groups_minus1)
        self.bottom_right = Array[int](self.num_slice_groups_minus1)
        for i in range(self.num_slice_groups_minus1):
          self.top_left[i] = int(ExpGolomb.udecode(rbsp))        
          self.bottom_right[i] = int(ExpGolomb.udecode(rbsp))        
      elif self.slice_group_map_type == 3 or \
           self.slice_group_map_type == 4 or \
           self.slice_group_map_type == 5:
        self.slice_group_change_direction_flag = bool(rbsp(1))
        self.slice_group_change_rate_minus1 = int(ExpGolomb.udecode(rbsp))
      elif self.slice_group_map_type == 6:
        self.pic_size_in_map_units_minus1 = int(ExpGolomb.udecode(rbsp))
        self.slice_group_id = Array[int](self.pic_size_in_map_units_minus1)
        for i in range(self.pic_size_in_map_units_minus1):
          self.slice_group_id[i] = int(rbsp(int(math.ceil(math.log2(self.num_slice_groups_minus1)+1))))
    self.num_ref_idx_l0_default_active_minus1 = int(ExpGolomb.udecode(rbsp))
    self.num_ref_idx_l1_default_active_minus1 = int(ExpGolomb.udecode(rbsp))
    self.weighted_pred_flag = bool(rbsp(1))
    self.weighted_bipred_idc = int(rbsp(2))
    self.pic_init_qp_minus26 = ExpGolomb.sdecode(rbsp)
    self.pic_init_qs_minus26 = ExpGolomb.sdecode(rbsp)
    self.chroma_qp_index_offset = ExpGolomb.sdecode(rbsp)
    self.deblocking_filter_control_present_flag = bool(rbsp(1))
    self.constrained_intra_pred_flag = bool(rbsp(1))
    self.redundant_pic_cnt_present_flag = bool(rbsp(1))
    if rbsp.bits_left():
      self.transform_8x8_mode_flag = bool(rbsp(1))
      self.pic_scaling_matrix_present_flag = bool(rbsp(1))
      if self.pic_scaling_matrix_present_flag:
        raise NotImplementedError()
        chroma_format_idc = video.find_sps_with_id(self.seq_parameter_set_id).chroma_format_idc
        bound = 6 + (2 if chroma_format_idc != 3 else 6) * int(self.transform_8x8_mode_flag)
        self.pic_scaling_list_present_flag = Array[bool](bound)
        for i in range(bound):
          self.pic_scaling_list_present_flag[i] = bool(rbsp(1))
          if self.pic_scaling_list_present_flag[i]:
            pass
        self.second_chroma_qp_index_offset = ExpGolomb.sdecode(rbsp)          
    
@extend
class VSlice:

  def __init__(self):
    self.first_mb_in_slice = 0
    self.slice_type = 0
    self.pic_parameter_set_id = 0
    self.colour_plane_id = 0
    self.frame_num = 0
    self.field_pic_flag = False
    self.bottom_field_flag = False
    self.idr_pic_id = 0
    self.pic_order_cnt_lsb = 0
    self.delta_pic_order_cnt_bottom = 0
    self.delta_pic_order_cnt = Array[int](2)
    self.delta_pic_order_cnt[0] = 0
    self.delta_pic_order_cnt[1] = 0
    self.redundant_pic_cnt = 0
    self.direct_spatial_mv_pred_flag = False
    self.num_ref_idx_active_override_flag = False
    self.num_ref_idx_l0_active_minus1 = 0
    self.num_ref_idx_l1_active_minus1 = 0
    self.cabac_init_idc = 0
    self.slice_qp_delta = 0
    self.sp_for_switch_flag = False
    self.slice_qs_delta = 0
    self.disable_deblocking_filter_idc = 0
    self.slice_alpha_c0_offset_div2 = 0
    self.slice_beta_offset_div2 = 0
    self.slice_group_change_cycle = 0
    self.ref_pic_list_modification_flag_l0 = False
    self.modification_of_pic_nums_idc = 0
    self.abs_diff_pic_num_minus1 = 0
    self.long_term_pic_num = 0
    self.ref_pic_list_modification_flag_l1 = False
    self.no_output_of_prior_pics_flag = False
    self.long_term_reference_flag = False
    self.adaptive_ref_pic_marking_mode_flag = False
    self.memory_management_control_operation = 0
    self.difference_of_pic_nums_minus1 = 0
    self.max_long_term_frame_idx_plus1 = 0
    self.long_term_frame_idx = 0

  def dump(self):
    cola_debug(self.first_mb_in_slice)
    cola_debug(self.slice_type)
    cola_debug(self.pic_parameter_set_id)
    cola_debug(self.colour_plane_id)
    cola_debug(self.frame_num)
    cola_debug(self.field_pic_flag)
    cola_debug(self.bottom_field_flag)
    cola_debug(self.idr_pic_id)
    cola_debug(self.pic_order_cnt_lsb)
    cola_debug(self.delta_pic_order_cnt_bottom)
    cola_debug(self.delta_pic_order_cnt)
    cola_debug(self.redundant_pic_cnt)
    cola_debug(self.direct_spatial_mv_pred_flag)
    cola_debug(self.num_ref_idx_active_override_flag)
    cola_debug(self.num_ref_idx_l0_active_minus1)
    cola_debug(self.num_ref_idx_l1_active_minus1)
    cola_debug(self.cabac_init_idc)
    cola_debug(self.slice_qp_delta)
    cola_debug(self.sp_for_switch_flag)
    cola_debug(self.slice_qs_delta)
    cola_debug(self.disable_deblocking_filter_idc)
    cola_debug(self.slice_alpha_c0_offset_div2)
    cola_debug(self.slice_beta_offset_div2)
    cola_debug(self.slice_group_change_cycle)
    cola_debug(self.ref_pic_list_modification_flag_l0)
    cola_debug(self.modification_of_pic_nums_idc)
    cola_debug(self.abs_diff_pic_num_minus1)
    cola_debug(self.long_term_pic_num)
    cola_debug(self.ref_pic_list_modification_flag_l1)
    cola_debug(self.no_output_of_prior_pics_flag)
    cola_debug(self.long_term_reference_flag)
    cola_debug(self.adaptive_ref_pic_marking_mode_flag)
    cola_debug(self.memory_management_control_operation)
    cola_debug(self.difference_of_pic_nums_minus1)
    cola_debug(self.max_long_term_frame_idx_plus1)
    cola_debug(self.long_term_frame_idx)

  def parse(self, nal_unit, video):
    self.slice_header(nal_unit, video)

  def slice_header(self, nal_unit, video):
    rbsp = nal_unit.rbsp_bytes
    self.first_mb_in_slice = int(ExpGolomb.udecode(rbsp))
    self.slice_type = int(ExpGolomb.udecode(rbsp))
    self.pic_parameter_set_id = int(ExpGolomb.udecode(rbsp))
    pps = video.find_pps_with_id(self.pic_parameter_set_id)
    sps_id = pps.seq_parameter_set_id
    sps = video.find_sps_with_id(sps_id)
    if sps.separate_colour_plane_flag == True:
      self.colour_plane_id = int(rbsp(2))
    self.frame_num = int(rbsp(int(sps.log2_max_frame_num_minus4)+4))
    if not sps.frame_mbs_only_flag:
      self.field_pic_flag = bool(rbsp(1))
      if self.field_pic_flag:        
        self.bottom_field_flag = bool(rbsp(1))
    idr_pic_flag = 1 if nal_unit.nal_unit_type == 5 else 0
    if idr_pic_flag:
      self.idr_pic_id = int(ExpGolomb.udecode(rbsp))
    if sps.pic_order_cnt_type == 0:
      self.pic_order_cnt_lsb = int(rbsp(int(sps.log2_max_pic_order_cnt_lsb_minus4)+4))
      if pps.bottom_field_pic_order_in_frame_present_flag and not self.field_pic_flag:
        self.delta_pic_order_cnt_bottom = ExpGolomb.sdecode(rbsp)
    if sps.pic_order_cnt_type == 1 and not sps.delta_pic_order_always_zero_flag:
      self.delta_pic_order_cnt[0] = ExpGolomb.sdecode(rbsp)
      if pps.bottom_field_pic_order_in_frame_present_flag and not self.field_pic_flag:
        self.delta_pic_order_cnt[1]
    if pps.redundant_pic_cnt_present_flag:
      self.redundant_pic_cnt = int(ExpGolomb.udecode(rbsp))
    if is_B_slice(self.slice_type):
      self.direct_spatial_mv_pred_flag = bool(rbsp(1))
    if is_P_slice(self.slice_type) or is_SP_slice(self.slice_type) or \
       is_B_slice(self.slice_type):
      self.num_ref_idx_active_override_flag = bool(rbsp(1))
      if self.num_ref_idx_active_override_flag:
        self.num_ref_idx_l0_active_minus1 = int(ExpGolomb.udecode(rbsp))
        if is_B_slice(self.slice_type):
          self.num_ref_idx_l1_active_minus1 = int(ExpGolomb.udecode(rbsp))
    if nal_unit.nal_unit_type == 20 or nal_unit.nal_unit_type == 21:
      raise NotImplementedError()
    else:
      self.ref_pic_list_modification(nal_unit, video)
    if (pps.weighted_pred_flag and \
        (is_P_slice(self.slice_type) or is_SP_slice(self.slice_type))) or \
        (pps.weighted_bipred_idc == 1 and is_B_slice(self.slice_type)):
      raise NotImplementedError()
    if nal_unit.nal_ref_idc != 0:
      self.dec_ref_pic_marking(nal_unit, video)
    if pps.entropy_coding_mode_flag and \
       not is_I_slice(self.slice_type) and not is_SI_slice(self.slice_type):
      self.cabac_init_idc = int(ExpGolomb.udecode(rbsp))
    self.slice_qp_delta = ExpGolomb.sdecode(rbsp)
    if is_SP_slice(self.slice_type) or is_SI_slice(self.slice_type):
      if is_SP_slice(self.slice_type):
        self.sp_for_switch_flag = bool(rbsp(1))
      self.slice_qs_delta = ExpGolomb.sdecode(rbsp)
    if pps.deblocking_filter_control_present_flag:
      self.disable_deblocking_filter_idc = int(ExpGolomb.udecode(rbsp))
      if self.disable_deblocking_filter_idc != 1:
        self.slice_alpha_c0_offset_div2 = ExpGolomb.sdecode(rbsp)
        self.slice_beta_offset_div2 = ExpGolomb.sdecode(rbsp)
    if pps.num_slice_groups_minus1 > 0 and pps.slice_group_map_type >= 3 and \
       pps.slice_group_map_type <= 5:
      self.slice_group_change_cycle = int(rbsp(int(math.ceil(math.log2((pps.pic_size_in_map_units_minus1 + 1) / (pps.slice_group_change_rate_minus1 + 1) + 1)))))

  def dec_ref_pic_marking(self, nal_unit, video):
    rbsp = nal_unit.rbsp_bytes
    idr_pic_flag = 1 if nal_unit.nal_unit_type == 5 else 0    
    if idr_pic_flag:
      self.no_output_of_prior_pics_flag = bool(rbsp(1))
      self.long_term_reference_flag = bool(rbsp(1))
    else:
      self.adaptive_ref_pic_marking_mode_flag = bool(rbsp(1))
      if self.adaptive_ref_pic_marking_mode_flag:
        idx = 0
        while idx == 0 or self.memory_management_control_operation != 0:
          idx += 1
          self.memory_management_control_operation = int(ExpGolomb.udecode(rbsp))
          if self.memory_management_control_operation == 1 or \
             self.memory_management_control_operation == 3:
            self.difference_of_pic_nums_minus1 = int(ExpGolomb.udecode(rbsp))
          if self.memory_management_control_operation == 2:
            self.long_term_pic_num = int(ExpGolomb.udecode(rbsp))
          if self.memory_management_control_operation == 3 or \
             self.memory_management_control_operation == 6:            
            self.long_term_frame_idx = int(ExpGolomb.udecode(rbsp))
          if self.memory_management_control_operation == 4:
            self.max_long_term_frame_idx_plus1 = int(ExpGolomb.udecode(rbsp))            
      
  def ref_pic_list_modification(self, nal_unit, video):
    rbsp = nal_unit.rbsp_bytes
    if self.slice_type % 5 != 2 and self.slice_type % 5 != 4:
      self.ref_pic_list_modification_flag_l0 = bool(rbsp(1))
      if self.ref_pic_list_modification_flag_l0:
        idx = 0
        # is there a do-while in seq?
        while idx == 0 or self.modification_of_pic_nums_idc != 3:
          idx += 1
          self.modification_of_pic_nums_idc = int(ExpGolomb.udecode(rbsp))
          if self.modification_of_pic_nums_idc == 0 or \
             self.modification_of_pic_nums_idc == 1:
            self.abs_diff_pic_num_minus1 = int(ExpGolomb.udecode(rbsp))
          elif self.modification_of_pic_nums_idc == 2:
            self.long_term_pic_num = int(ExpGolomb.udecode(rbsp))          
    if self.slice_type % 5 == 1:
      self.ref_pic_list_modification_flag_l1 = bool(rbsp(1))
      if self.ref_pic_list_modification_flag_l1:
        idx = 0
        # is there a do-while in seq?
        while idx == 0 or self.modification_of_pic_nums_idc != 3:
          idx += 1
          self.modification_of_pic_nums_idc = int(ExpGolomb.udecode(rbsp))
          if self.modification_of_pic_nums_idc == 0 or \
             self.modification_of_pic_nums_idc == 1:
            self.abs_diff_pic_num_minus1 = int(ExpGolomb.udecode(rbsp))
          elif self.modification_of_pic_nums_idc == 2:
            self.long_term_pic_num = int(ExpGolomb.udecode(rbsp))          
      

@extend
class IDRCodedSlice:
  
  def __init__(self):
    self.slc = VSlice()

  def dump(self):
    self.slc.dump()

  def parse(self, nal_unit, video: Video):
    self.slc.parse(nal_unit, video)

@extend    
class NALUnit:

# all the useful stuff parsed from annex b
  
  def __init__(self, original_stream):
    self.original_stream = original_stream
    self.nal_unit_type = 0
    self.nal_ref_idc = 0
    self.svc_extension_flag = False
    self.avc_3d_extension_flag = False
    self.rbsp_bytes = Bits[64]()
    self.sps = None
    self.pps = None
    self.idr_cs = None

  def dump(self):
    cola_debug(self.nal_unit_type)
    cola_debug(self.nal_ref_idc)
    cola_debug(self.svc_extension_flag)
    cola_debug(self.avc_3d_extension_flag)
    rbsp_nbytes = len(self.rbsp_bytes) // 8
    cola_debug(rbsp_nbytes)
    if self.sps:
      self.sps.dump()
    if self.pps:
      self.pps.dump()
    if self.idr_cs:
      self.idr_cs.dump()

  # parse the correct thing based on nal_unit_type
  def interpret_rbsp(self, video: Video):
    if self.nal_unit_type == 0:
      raise NALError("undefined")
    elif self.nal_unit_type == 1:
      raise NotImplementedError()
    elif self.nal_unit_type == 2:
      raise NotImplementedError()
    elif self.nal_unit_type == 3:
      raise NotImplementedError()
    elif self.nal_unit_type == 4:
      raise NotImplementedError()
    elif self.nal_unit_type == 5:
      self.idr_cs = IDRCodedSlice()
      self.idr_cs.parse(self, video)
    elif self.nal_unit_type == 6:
      raise NotImplementedError()
    elif self.nal_unit_type == 7:
      self.sps = SeqParameterSet()
      self.sps.parse(self)
    elif self.nal_unit_type == 8:
      self.pps = PicParameterSet()
      self.pps.parse(self, video)
    elif self.nal_unit_type == 9:
      raise NotImplementedError()
    elif self.nal_unit_type == 10:
      raise NotImplementedError()
    elif self.nal_unit_type == 11:
      raise NotImplementedError()
    elif self.nal_unit_type == 12:
      raise NotImplementedError()
    elif self.nal_unit_type == 13:
      raise NotImplementedError()
    elif self.nal_unit_type == 14:
      raise NotImplementedError()
    elif self.nal_unit_type == 15:
      raise NotImplementedError()
    elif self.nal_unit_type == 16:
      raise NotImplementedError()
    elif self.nal_unit_type == 17:
      raise NALError("reserved")
    elif self.nal_unit_type == 18:
      raise NALError("reserved")
    elif self.nal_unit_type == 19:
      raise NotImplementedError()
    elif self.nal_unit_type == 20:
      raise NotImplementedError()
    elif self.nal_unit_type == 21:
      raise NotImplementedError()
    elif self.nal_unit_type == 22:
      raise NotImplementedError()
    elif self.nal_unit_type == 23:
      raise NALError("reserved")
    else:
      raise NALError("unspecified")


  # annex G
  def nal_unit_header_svc_extension(self):
    raise NotImplementedError()
  
  # annex J
  def nal_unit_header_3davc_extension(self):
    raise NotImplementedError()

  # annex H
  def nal_unit_header_mvc_extension(self):
    raise NotImplementedError()  

# Produces a nal unit
# 7.3.1
def nal_unit(bits: Bits[64]) -> NALUnit:
  cur_nal_unit = NALUnit(bits)
  num_bytes_in_nal_unit = len(bits) // 8
  check_val(bits(1), u64(0), "forbidden_zero_bit")
  cur_nal_unit.nal_ref_idc = int(bits(2))
  cur_nal_unit.nal_unit_type = int(bits(5))
  nal_unit_header_bytes = 1
  if cur_nal_unit.nal_unit_type == 14 or \
     cur_nal_unit.nal_unit_type == 20 or \
     cur_nal_unit.nal_unit_type == 21:
    if cur_nal_unit.nal_unit_type != 21:
      cur_nal_unit.svc_extension_flag = bool(bits(1))
    else:
      cur_nal_unit.avc_3d_extension_flag = bool(bits(1))
    if cur_nal_unit.svc_extension_flag:
      cur_nal_unit.nal_unit_header_svc_extension()
      nal_unit_header_bytes += 3
    elif cur_nal_unit.avc_3d_extension_flag:
      cur_nal_unit.nal_unit_header_3davc_extension()
      nal_unit_header_bytes += 2
    else:
      cur_nal_unit.nal_unit_header_mvc_extension()
      nal_unit_header_bytes += 3
  for i in range(nal_unit_header_bytes, num_bytes_in_nal_unit):
    if bits.bits_left(24) and bits.peek(24) == u64(0x000003):
      cur_nal_unit.rbsp_bytes.pack(bits(16),16)
      i += 2
      check_val(bits(8), u64(0x03), "emulation_prevention_three_byte")
    else:
      cur_nal_unit.rbsp_bytes.pack(bits(8),8)
  return cur_nal_unit

