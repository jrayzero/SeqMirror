from cola.bitseq import *
from golomb import *

class NALError:
  _hdr: ExcHeader

  def __init__(self):
    self._hdr = ('NALError', '', '', '', 0, 0)
    
  def __init__(self, message: str):
    self._hdr = ('NALError', message, '', '', 0, 0)
      
  @property
  def message(self):
    return self._hdr.msg

def check_val(val, ref, val_name):
  if val != ref:
    raise NALError(val_name + "(" + str(val) + ") != " + str(ref))
  else:
    return val

class SeqParameterSet:
  profile_idc: int
  constraint_set0_flag: bool
  constraint_set1_flag: bool
  constraint_set2_flag: bool
  constraint_set3_flag: bool
  constraint_set4_flag: bool
  constraint_set5_flag: bool
  level_idc: int
  seq_parameter_set_id: u64
  chroma_format_idc: u64
  separate_colour_plane_flag: bool
  bit_depth_luma_minus8: u64
  bit_depth_chroma_minus8: u64
  qpprime_y_zero_transform_bypass_flag: bool
  seq_scaling_matrix_present_flag: bool
  seq_scaling_list_present_flag: Array[bool]
  scaling_list: Array[Array[int]]
  log2_max_frame_num_minus4: u64
  pic_order_cnt_type: u64
  log2_max_pic_order_cnt_lsb_minus4: u64
  delta_pic_order_always_zero_flag: bool
  offset_for_non_ref_pic: int
  offset_for_top_to_bottom_field: int
  num_ref_frames_in_pic_order_cnt_cycle: u64
  offset_for_ref_frame: Array[int]
  max_num_ref_frames: u64
  gaps_in_frame_num_value_allowed_flag: bool
  pic_width_in_mbs_minus1: u64
  pic_height_in_map_units_minus1: u64
  frame_mbs_only_flag: bool
  mb_adaptive_frame_field_flag: bool
  direct_8x8_inference_flag: bool
  frame_cropping_flag: bool
  frame_crop_left_offset: u64
  frame_crop_right_offset: u64
  frame_crop_top_offset: u64
  frame_crop_bottom_offset: u64
  vui_parameters_present_flag: bool
  

class NALUnit:
  original_stream: Bits[64]
  nal_unit_type: int
  nal_ref_idc: int
  svc_extension_flag: bool
  avc_3d_extension_flag: bool
  rbsp_bytes: Bits[64]    
  # the stuff here is conditionally filled based on the nal unit type
  sps: Optional[SeqParameterSet]

@extend
class SeqParameterSet:

  def __init__(self):
    self.profile_idc = 0
    self.constraint_set0_flag = False
    self.constraint_set1_flag = False
    self.constraint_set2_flag = False
    self.constraint_set3_flag = False
    self.constraint_set4_flag = False
    self.constraint_set5_flag = False
    self.level_idc = 0
    self.seq_parameter_set_id = u64(0)
    self.chroma_format_idc = u64(0)
    self.separate_colour_plane_flag = False
    self.bit_depth_luma_minus8 = u64(0)
    self.bit_depth_chroma_minus8 = u64(0)
    self.qpprime_y_zero_transform_bypass_flag = False
    self.seq_scaling_matrix_present_flag = False
 #   self.seq_scaling_list_present_flag = Array[bool]()    
    # not using block here because these are arrays of different sizes (so not a block shape)
    #    self.scaling_list = SeqParameterSet.make_default_scaling_lists()
    self.log2_max_frame_num_minus4 = u64(0)
    self.pic_order_cnt_type = u64(0)
    self.log2_max_pic_order_cnt_lsb_minus4 = u64(0)
    self.delta_pic_order_always_zero_flag = False
    self.offset_for_non_ref_pic = 0
    self.offset_for_top_to_bottom_field = 0
    self.num_ref_frames_in_pic_order_cnt_cycle = u64(0)
#    self.offset_for_ref_frame = Array[int]()
    self.max_num_ref_frames = u64(0)
    self.gaps_in_frame_num_value_allowed_flag = False
    self.pic_width_in_mbs_minus1 = u64(0)
    self.pic_height_in_map_units_minus1 = u64(0)
    self.frame_mbs_only_flag = False
    self.mb_adaptive_frame_field_flag = False
    self.direct_8x8_inference_flag = False
    self.frame_cropping_flag = False
    self.frame_crop_left_offset = u64(0)
    self.frame_crop_right_offset = u64(0)
    self.frame_crop_top_offset = u64(0)
    self.frame_crop_bottom_offset = u64(0)
    self.vui_parameters_present_flag = False


#  def make_default_scaling_lists():
#    scaling_list = Array[Array[int]](12)
#    default_4x4_intra = [6,13,13,20,20,20,28,28,28,28,32,32,32,37,37,42]
#    default_4x4_inter = [10,14,14,20,20,20,24,24,24,24,27,27,27,30,30,34]
#    default_8x8_intra = [6,10,10,13,11,13,16,16,16,16,18,18,18,18,18,23,23,23,23,23,23,25,25,25,25,25,25,25,27,27,27,27,27,27,27,27,29,29,29,29,29,29,29,31,31,31,31,31,31,33,33,33,33,33,36,36,36,36,38,38,38,40,40,42]
#    default_8x8_inter = [9,13,13,15,13,15,17,17,17,17,19,19,19,19,19,21,21,21,21,21,21,22,22,22,22,22,22,22,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,27,27,27,27,27,27,28,28,28,28,28,30,30,30,30,32,32,32,33,33,35]
#    scaling_list[0] = default_4x4_intra
#    scaling_list[1] = default_4x4_intra
#    scaling_list[2] = default_4x4_intra
#    scaling_list[3] = default_4x4_inter
#    scaling_list[4] = default_4x4_inter
#    scaling_list[5] = default_4x4_inter
#    scaling_list[6] = default_8x8_intra
#    scaling_list[7] = default_8x8_inter
#    scaling_list[8] = default_8x8_intra
#    scaling_list[9] = default_8x8_inter
#    scaling_list[10] = default_8x8_intra
#    scaling_list[11] = default_8x8_inter
#    return scaling_list

  def dump(self):
    # TODO have a compiler function that lets you print all the fields of an object (shove in IR pass)
    cola_debug(self.profile_idc)
    cola_debug(self.constraint_set0_flag)
    cola_debug(self.constraint_set1_flag)
    cola_debug(self.constraint_set2_flag)
    cola_debug(self.constraint_set3_flag)
    cola_debug(self.constraint_set4_flag)
    cola_debug(self.constraint_set5_flag)
    cola_debug(self.level_idc)
    cola_debug(self.seq_parameter_set_id)
    cola_debug(self.chroma_format_idc)
    cola_debug(self.separate_colour_plane_flag)
    cola_debug(self.bit_depth_luma_minus8)
    cola_debug(self.bit_depth_chroma_minus8)
    cola_debug(self.qpprime_y_zero_transform_bypass_flag)
    cola_debug(self.seq_scaling_matrix_present_flag)
    cola_debug(self.seq_scaling_list_present_flag)
    cola_debug(self.log2_max_frame_num_minus4)
    cola_debug(self.pic_order_cnt_type)
    cola_debug(self.log2_max_pic_order_cnt_lsb_minus4)
    cola_debug(self.delta_pic_order_always_zero_flag)
    cola_debug(self.offset_for_non_ref_pic)
    cola_debug(self.offset_for_top_to_bottom_field)
    cola_debug(self.num_ref_frames_in_pic_order_cnt_cycle)
    cola_debug(self.offset_for_ref_frame)
    cola_debug(self.max_num_ref_frames)
    cola_debug(self.gaps_in_frame_num_value_allowed_flag)
    cola_debug(self.pic_width_in_mbs_minus1)
    cola_debug(self.pic_height_in_map_units_minus1)
    cola_debug(self.frame_mbs_only_flag)
    cola_debug(self.mb_adaptive_frame_field_flag)
    cola_debug(self.direct_8x8_inference_flag)
    cola_debug(self.frame_cropping_flag)
    cola_debug(self.frame_crop_left_offset)
    cola_debug(self.frame_crop_right_offset)
    cola_debug(self.frame_crop_top_offset)
    cola_debug(self.frame_crop_bottom_offset)
    cola_debug(self.vui_parameters_present_flag)
    
  def parse(self, nal_unit):
    self.seq_parameter_set_rbsp(nal_unit)

  # these names match the standard
  def seq_parameter_set_rbsp(self, nal_unit):
    self.seq_parameter_set_data(nal_unit)

  def seq_parameter_set_data(self, nal_unit):
    rbsp = nal_unit.rbsp_bytes
    self.profile_idc = int(rbsp(8))
    self.constraint_set0_flag = bool(rbsp(1))
    self.constraint_set1_flag = bool(rbsp(1))
    self.constraint_set2_flag = bool(rbsp(1))
    self.constraint_set3_flag = bool(rbsp(1))
    self.constraint_set4_flag = bool(rbsp(1))
    self.constraint_set5_flag = bool(rbsp(1))
    check_val(rbsp(2), u64(0), "reserved_zero_bits")
    self.level_idc = int(rbsp(8))
    self.seq_parameter_set_id = ExpGolomb.udecode(rbsp)
    if self.profile_idc == 100 or self.profile_idc == 110 \
       or self.profile_idc == 122 or self.profile_idc == 244 \
       or self.profile_idc == 44 or self.profile_idc == 83 \
       or self.profile_idc == 86 or self.profile_idc == 118 \
       or self.profile_idc == 128 or self.profile_idc == 138 \
       or self.profile_idc == 139 or self.profile_idc == 134 \
       or self.profile_idc == 135:
      self.chroma_format_idc = ExpGolomb.udecode(rbsp)
      if self.chroma_format_idc == u64(3):
        self.separate_colour_plane_flag = bool(rbsp(1))
      self.bit_depth_luma_minus8 = ExpGolomb.udecode(rbsp)
      self.bit_depth_chroma_minus8 = ExpGolomb.udecode(rbsp)
      self.qpprime_y_zero_transform_bypass_flag = bool(rbsp(1))
      self.seq_scaling_matrix_present_flag = bool(rbsp(1))
      if self.seq_scaling_matrix_present_flag:
        amt = 8 if self.chroma_format_idc != u64(3) else 12
        self.seq_scaling_list_present_flag = Array[bool](amt)
        for i in range(amt):
          b = bool(rbsp(1))
          self.seq_scaling_list_present_flag[i] = b
          raise NotImplementedError()
    self.log2_max_frame_num_minus4 = ExpGolomb.udecode(rbsp)
    self.pic_order_cnt_type = ExpGolomb.udecode(rbsp)
    if self.pic_order_cnt_type == u64(0):
      self.log2_max_pic_order_cnt_lsb_minus4 = ExpGolomb.udecode(rbsp)
    elif self.pic_order_cnt_type == u64(1):
      self.delta_pic_order_always_zero_flag = bool(rbsp(1))
      self.offset_for_non_ref_pic = ExpGolomb.sdecode(rbsp)
      self.offset_for_top_to_bottom_field = ExpGolomb.sdecode(rbsp)
      self.num_ref_frames_in_pic_order_cnt_cycle = ExpGolomb.udecode(rbsp)
      self.offset_for_ref_frame = Array[int](int(self.num_ref_frames_in_pic_order_cnt_cycle))
      for i in range(int(self.num_ref_frames_in_pic_order_cnt_cycle)):
        self.offset_for_ref_frame[i] = ExpGolomb.sdecode(rbsp)
    self.max_num_ref_frames = ExpGolomb.udecode(rbsp)
    self.gaps_in_frame_num_value_allowed_flag = bool(rbsp(1))
    self.pic_width_in_mbs_minus1 = ExpGolomb.udecode(rbsp) 
    self.pic_height_in_map_units_minus1 = ExpGolomb.udecode(rbsp)
    self.frame_mbs_only_flag = bool(rbsp(1))
    if not self.frame_mbs_only_flag:
      self.mb_adaptive_frame_field_flag = bool(rbsp(1))
    self.direct_8x8_inference_flag = bool(rbsp(1))
    self.frame_cropping_flag = bool(rbsp(1))
    if self.frame_cropping_flag:
      self.frame_crop_left_offset = ExpGolomb.udecode(rbsp)
      self.frame_crop_right_offset = ExpGolomb.udecode(rbsp)
      self.frame_crop_top_offset = ExpGolomb.udecode(rbsp)
      self.frame_crop_bottom_offset = ExpGolomb.udecode(rbsp)
    self.vui_parameters_present_flag = bool(rbsp(1))
    if self.vui_parameters_present_flag:
      raise NotImplementedError()

@extend    
class NALUnit:

# all the useful stuff parsed from annex b
  
  def __init__(self, original_stream):
    self.original_stream = original_stream
    self.nal_unit_type = 0
    self.nal_ref_idc = 0
    self.svc_extension_flag = False
    self.avc_3d_extension_flag = False
    self.rbsp_bytes = Bits[64]()
    self.sps = None

  def dump(self):
    cola_debug(self.nal_unit_type)
    cola_debug(self.nal_ref_idc)
    cola_debug(self.svc_extension_flag)
    cola_debug(self.avc_3d_extension_flag)
    rbsp_nbytes = len(self.rbsp_bytes) // 8
    cola_debug(rbsp_nbytes)
    if self.sps:
      self.sps.dump()

  # parse the correct thing based on nal_unit_type
  def interpret_rbsp(self):
    if self.nal_unit_type == 7:
      self.sps = SeqParameterSet()
      self.sps.parse(self)
      # TODO
#      self.rbsp_bytes.clear()

  # annex G
  def nal_unit_header_svc_extension(self):
    raise NotImplementedError()
  
  # annex J
  def nal_unit_header_3davc_extension(self):
    raise NotImplementedError()

  # annex H
  def nal_unit_header_mvc_extension(self):
    raise NotImplementedError()  

# Produces a nal unit
# 7.3.1
def nal_unit(bits: Bits[64]) -> NALUnit:
  cur_nal_unit = NALUnit(bits)
  num_bytes_in_nal_unit = len(bits) // 8
  check_val(bits(1), u64(0), "forbidden_zero_bit")
  cur_nal_unit.nal_ref_idc = int(bits(2))
  cur_nal_unit.nal_unit_type = int(bits(5))
  nal_unit_header_bytes = 1
  if cur_nal_unit.nal_unit_type == 14 or \
     cur_nal_unit.nal_unit_type == 20 or \
     cur_nal_unit.nal_unit_type == 21:
    if cur_nal_unit.nal_unit_type != 21:
      cur_nal_unit.svc_extension_flag = bool(bits(1))
    else:
      cur_nal_unit.avc_3d_extension_flag = bool(bits(1))
    if cur_nal_unit.svc_extension_flag:
      cur_nal_unit.nal_unit_header_svc_extension()
      nal_unit_header_bytes += 3
    elif cur_nal_unit.avc_3d_extension_flag:
      cur_nal_unit.nal_unit_header_3davc_extension()
      nal_unit_header_bytes += 2
    else:
      cur_nal_unit.nal_unit_header_mvc_extension()
      nal_unit_header_bytes += 3
  for i in range(nal_unit_header_bytes, num_bytes_in_nal_unit):
    if bits.bits_left(24) and bits.peek(24) == u64(0x000003):
      cur_nal_unit.rbsp_bytes.pack(bits(16),16)
      i += 2
      check_val(bits(8), u64(0x03), "emulation_prevention_three_byte")
    else:
      cur_nal_unit.rbsp_bytes.pack(bits(8),8)
  return cur_nal_unit

