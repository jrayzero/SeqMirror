from cola.block import *
from common import *
from config import *

# TODO for availability, you also hae to check if the recons blk was down with inter mode
# and see if that isn't allowed

def intra_16x16_luma_m0(smb, rblk) -> Optional[Block[int]]:
  ref = rblk[smb]
  f,h,w = ref.origin()
  # get a view on the row above you in rblk
  if h > 0:
    row = ref[0,-1,:]
    pred = Block(smb)
    for i,r in enumerate(row):
      pred[0,:,i] = r()
    return pred
  return None
  
def intra_16x16_luma_m1(smb, rblk) -> Optional[Block[int]]:
  ref = rblk[smb]
  f,h,w = ref.origin()
  if w > 0:
    col = ref[0,:,-1]
    pred = Block(smb)
    for i,c in enumerate(col):
      pred[0,i,:] = c()
    return pred
  return None

def intra_16x16_luma_m2(smb, rblk) -> Optional[Block[int]]:
  ref = rblk[smb]
  f,h,w = ref.origin()
  if h > 0 and w > 0:
    row = ref[0,-1,:]
    col = ref[0,:,-1]
    cola_debug(row)
    cola_debug(col)
    # reductions
    s = 0
    for r,c in zip(row,col):
      s += r() + c()
    pred = Block[int](smb)
    pred[:,:,:] = (s + 16) >> 5
    return pred
  elif w > 0:
    col = ref[0,:,-1]
    # reductions
    sum_y = 0
    for c in col:
      sum_y += c()
    pred = Block[int](smb)
    pred[:,:,:] = (sum_y + 8) >> 4
    return pred
  elif h > 0:
    row = ref[0,-1,:]
    # reductions
    sum_x = 0
    for r in row:
      sum_x += r()
    pred = Block[int](smb)
    pred[:,:,:] = (sum_x + 8) >> 4
    return pred    
  else:
    pred = Block[int](smb)
    pred[:,:,:] = 1 << (bit_depth_y - 1)
    return pred

def intra_16x16_luma_m3(smb, rblk) -> Optional[Block[int]]:
  ref = rblk[smb]
  f,h,w = ref.origin()
  if h > 0 and w > 0:
    row = ref[0,-1,:]
    col = ref[0,:,-1]
    # pull out the pieces to compute H    
    H = 0
    pH1 = row[0,:,8:]
    pH2 = row[0,:,:7]    
    for r,h1,h2 in zip(range(8),pH1, pH2):
      H += (r+1)*(h1()-h2())      
    # and the pieces for V
    V = 0
    pV1 = col[0,8:,:]
    pV2 = col[0,:7,:]
    for r,v1,v2 in zip(range(8),pV1, pV2):
      V += (r+1)*(v1()-v2())          
    a = 16 * (rblk(0,15,0)+rblk(0,0,16))
    b = (5 * H + 32) >> 6
    c = (5 * V + 32) >> 6
    pred = Block[int](smb)
    for y in range(16):
      for x in range(16):
        clip_val = (a + b * (x - 7) + c * (y - 7) + 16) >> 5
        pred[0,y,x] = (clip1y(clip_val))
    return pred    
  else:
    return None

# TODO filtering for 8x8
def intra_8x8_luma_vert(smb, frblk) -> Optional[Block[int]]:
  ref = frblk[smb]
  f,h,w = ref.origin()
  if h > 0:
    pred = Block(smb)
    row = ref[0,-1,:]
    for prow,r in enumerate(row):
      pred[0,prow,:] = r()
    return pred
  else:
    return None

def intra_8x8_luma_horiz(smb, frblk) -> Optional[Block[int]]:
  ref = frblk[smb]
  f,h,w = ref.origin()
  if w > 0:
    pred = Block(smb)
    col = ref[0,:,-1]
    for pcol,c in enumerate(col):
      pred[0,:,pcol] = c()
    return pred
  else:
    return None

def intra_8x8_luma_DC(smb, rblk) -> Optional[Block[int]]:  
  ref = rblk[smb]
  f,h,w = ref.origin()
  if h > 0 and w > 0:
    pred = Block(smb)
    sum = 0 
    for i in range(8):
      sum += ref(0,-1,i)
      sum += ref(0,i,-1)
    sum = (sum + 8) >> 4
    pred[:,:,:] = sum
    return pred
  elif w > 0:
    pred = Block(smb)
    sum = 0 
    for i in range(8):
      sum += ref(0,i,-1)
    sum = (sum + 4) >> 3
    pred[:,:,:] = sum
    return pred
  elif h > 0:
    pred = Block(smb)
    sum = 0 
    for i in range(8):
      sum += ref(0,-1,i)
    sum = (sum + 4) >> 3
    pred[:,:,:] = sum
    return pred      
  else:
    pred = Block(smb)
    pred[:,:,:] = 1 << (bit_depth_y - 1)    
    return pred

def intra_8x8_luma_ddl(smb, frblk) -> Optional[Block[int]]:
  ref = frblk[smb]
  f,h,w = ref.origin()
  if h > 0:
    pred = Block(smb)
     # x=y=7
    pred[0,7,7] = (ref(0,-1,14) + 3 * ref(0,-1,15) + 2) >> 2
    for y in range(7):
      for x in range(7):
        pred[0,y,x] = (ref(0,-1,x+y) + 2 * ref(0,-1,x+y+1) + ref(0,-1,x+y+2) + 2) >> 2
    return pred
  else:
    return None

def intra_8x8_luma_ddr(smb, frblk) -> Optional[Block[int]]:
  ref = frblk[smb]
  f,h,w = ref.origin()
  if h > 1 and w > 1:
    pred = Block(smb)
    for y in range(8):
      for x in range(8):
        if x > y:
          pred[0,y,x] = (ref(0,-1,x-y-2) + 2 * ref(0,-1,x-y-1) + ref(0,-1,x-y) + 2) >> 2
        elif x < y:
          pred[0,y,x] = (ref(0,y-x-2,-1) + 2 * ref(0,y-x-1,-1) + ref(0,y-x,-1) + 2) >> 2
        else:
          pred[0,y,x] = (ref(0,-1,0) + 2 * ref(0,-1,-1) + ref(0,0,-1) + 2) >> 2
    return pred
  else:
    return None

# HMM OPT THOUGHT...can we automatically vectorize some of these things to be element-wise like?
def intra_8x8_luma_vertr(smb, frblk) -> Optional[Block[int]]:
  ref = frblk[smb]
  f,h,w = ref.origin()
  if h > 1 and w > 1:
    pred = Block(smb)
    for y in range(8):
      for x in range(8):
        zVR = 2 * x - y
        if zVR < 0:
          if zVR == -1:
            pred[0,y,x] = (ref(0,0,-1) + 2 * ref(0,-1,-1) + ref(0,-1,0) + 2) >> 2
          else:
            pred[0,y,x] = (ref(0,y-2*x-1,-1) + 2 * ref(0,y-2*x-2,-1) + ref(0,y-2*x-3,-1) + 2) >> 2
        elif zVR & 1 == 0:
          # even number
          pred[0,y,x] = (ref(0,-1,x-(y>>1)-1) + ref(0,-1,x-(y>>1)) + 1) >> 1
        else:
          # odd number
          pred[0,y,x] = (ref(0,-1,x-(y>>1)-2) + 2 * ref(0,-1,x-(y>>1)) + ref(0,-1,x-(y>>1)) + 2) >> 2
    return pred
  else:
    return None

def intra_8x8_luma_horizd(smb, frblk) -> Optional[Block[int]]:
  ref = frblk[smb]
  f,h,w = ref.origin()
  if h > 1 and w > 1:
    pred = Block(smb)
    for y in range(8):
      for x in range(8):
        zHD = 2 * y - x
        if zHD < 0:
          if zHD == -1:
            pred[0,y,x] = (ref(0,0,-1) + 2 * ref(0,-1,-1) + ref(0,-1,0) + 2) >> 2
          else:
            pred[0,y,x] = (ref(0,-1,x-2*y-1) + 2 * ref(0,-1,x-2*y-2) + ref(0,-1,x-2*y-3) + 2) >> 2
        elif zHD & 1 == 0:
          # even number
          pred[0,y,x] = (ref(0,y-(x>>1)-1,-1) + ref(0,-1,y-(x>>1)) + 1) >> 1
        else:
          # odd number
          pred[0,y,x] = (ref(0,y-(x>>1)-2,-1) + 2 * ref(0,y-(x>>1),-1) + ref(0,y-(x>>1),-1) + 2) >> 2
    return pred
  else:
    return None

def intra_8x8_luma_vertl(smb, frblk) -> Optional[Block[int]]:
  ref = frblk[smb]
  f,h,w = ref.origin()
  if h > 0:
    pred = Block(smb)
    for y in range(0,8,2):
      for x in range(8):
        pred[0,y,x] = (ref(0,-1,x+(y>>1)) + ref(0,-1,x+(y>>1)+1) + 1) >> 1
    for y in range(1,8,2):
      for x in range(8):
        pred[0,y,x] = (ref(0,-1,x+(y>>1)) + ref(0,-1,x+(y>>1)+1) + 2) >> 2
    return pred
  return None

def intra_8x8_luma_horizu(smb, frblk) -> Optional[Block[int]]:
  ref = frblk[smb]
  f,h,w = ref.origin()
  if w > 0:
    pred = Block(smb)
    for y in range(8):
      for x in range(8):
        zHU = x+2*y
        if zHU & 1 == 0:
          pred[0,y,x] = (ref(0,y+(x>>1),-1) + ref(0,y+(x>>1)+1,-1)+1) >> 1
        elif zHU == 13:
          pred[0,y,x] = (ref(0,6,-1) + 3 * ref(0,7,-1) + 2) >> 2
        elif zHU > 13:
          pred[0,y,x] = ref(0,7,-1)
        else:
          pred[0,y,x] = (ref(0,y+(x>>1),-1) + 2 * ref(0,y+(x>>1)+1,-1) + ref(0,y+(x>>1)+2,-1)) >> 2
    return pred
  return None

