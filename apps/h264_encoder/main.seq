from read_yuv import *
from intra import *
from config import *
from quant import *
from transform import *
from partition import *
from cola.block import *
from cola.parallel_support import *

def xform_code_16x16(mb, intra_coded_mb, rmb):
  residual = mb - intra_coded_mb
  xform = xform_luma_16x16_mb(residual)
  DCs = xform[0,::4,::4]
  quant_dc4x4_normal(DCs, QP)
  # TODO pretend I quantized everything 
  return xform, residual

y_frames,u_frames,v_frames = ingest_yuv_420_interleaved_all(False)

y_cgrid = y_frames.base.cgrid
u_cgrid = u_frames.base.cgrid
v_cgrid = v_frames.base.cgrid


# reconstructed frames
# These contain the final selections for reconstruction (i.e. the reconstruction
# of the "best" choice)
# NOTE TO SELF: just overwrite the input frame. I don't need it anymore
#ry_frames = Block[int](y_frames)
#ru_frames = Block[int](u_frames)
#rv_frames = Block[int](v_frames)

# decoded picture buffer
dpb = list[View[u8]]()

# no slices
for idx,f in enumerate(range(nframes)):
  y_frame = y_frames[f,:,:]
#  ry_frame = ry_frames[f,:,:]
  for r in range(0,y_frame.dims(1),16):
    for c in range(0,y_frame.dims(2),16):
      mb = y_frame[0,r:r+16,c:c+16]
            
      ### 16x16 Intra-Prediction 

      # try prediction
      intra_16x16_pred_m0 = intra_16x16_luma_m0(mb, ry_frame)
      intra_16x16_pred_m1 = intra_16x16_luma_m1(mb, ry_frame)
      intra_16x16_pred_m2 = intra_16x16_luma_m2(mb, ry_frame)
      intra_16x16_pred_m3 = intra_16x16_luma_m3(mb, ry_frame)
      
      # compute residuals
      residual_16x16_pred_m0 = Block[int]()
      residual_16x16_pred_m1 = Block[int]()
      residual_16x16_pred_m2 = Block[int]()
      residual_16x16_pred_m3 = Block[int]()
      if intra_16x16_pred_m0:
        residual_16x16_pred_m0 = mb - ~intra_16x16_pred_m0
      if intra_16x16_pred_m1:
        residual_16x16_pred_m1 = mb - ~intra_16x16_pred_m1
      if intra_16x16_pred_m2:
        residual_16x16_pred_m2 = mb - ~intra_16x16_pred_m2
      if intra_16x16_pred_m3:
        residual_16x16_pred_m3 = mb - ~intra_16x16_pred_m3

      # store costs
      costs_16x16 = [INT_MAX] * 4

      

      # 8x8 and 4x4 intra-prediction      
#      submbs_8x8 = split_4x4(mb, 16)[0]
#      costs_submbs_8x8 = Array[int](len(submbs_8x8))
#      preds_submbs_8x8 = Array[Block[int]](len(submbs_8x8))
#      for idx,leaf in par(enumerate(submbs_8x8)):
#        # do the 8x8 modes
#        intra_8x8_pred_m0 = intra_8x8_luma_vert(leaf, ry_frame)
#        intra_8x8_pred_m1 = intra_8x8_luma_horiz(leaf, ry_frame)
#        intra_8x8_pred_m2 = intra_8x8_luma_DC(leaf, ry_frame)
#        intra_8x8_pred_m3 = intra_8x8_luma_ddl(leaf, ry_frame)
#        intra_8x8_pred_m4 = intra_8x8_luma_ddr(leaf, ry_frame)
#        intra_8x8_pred_m5 = intra_8x8_luma_vertr(leaf, ry_frame)
#        intra_8x8_pred_m6 = intra_8x8_luma_horizd(leaf, ry_frame)
#        intra_8x8_pred_m7 = intra_8x8_luma_vertl(leaf, ry_frame)
#        intra_8x8_pred_m8 = intra_8x8_luma_horizu(leaf, ry_frame)
#        # xform, quantize, then undo to eventually get cost
#        costs_submbs_8x8[idx] = idx
#        preds_submbs_8x8[idx] = intra_8x8_pred_m2

#
#      task_sync(0,1,2,3)
#      if not residual_16x16_pred_m0.base.invalid:
#        cola_debug(residual_16x16_pred_m0)
#      if not residual_16x16_pred_m1.base.invalid:
#        cola_debug(residual_16x16_pred_m1)
#      if not residual_16x16_pred_m2.base.invalid:
#        cola_debug(residual_16x16_pred_m2)
#      if not residual_16x16_pred_m3.base.invalid:
#        cola_debug(residual_16x16_pred_m3)
      
      assert False


      # residuals, transform, quantize
      # run 4x4 on each within the macroblock
#      if intra_16x16_m0:
#        quantized,residual = xform_code_16x16(mb, ~intra_16x16_m0)
        # inverse quant, inverse xform, then add to residual
        # FAKE IT
#        reconstructed_residual = residual + (residual + 50) 
        # compute diff between the reconstructed residual and 
        # the original mb
#        diff = mb - reconstruced_residual
        

#      if intra_16x16_m1:
#        xform_code_16x16(mb, ~intra_16x16_m1)

#      if intra_16x16_m2:
#        xform_code_16x16(mb, ~intra_16x16_m2)

#      if intra_16x16_m3:
#        xform_code_16x16(mb, ~intra_16x16_m3)
        
        

      # pick the best intra prediction

      # do a ptree thing with 

      # TODO inter-prediction
#      ptree = make_interptree()
#      min_cost = MAX_INT
#      best_inter_pred = Block(mb)
#      for aptree in ptree(mb):
#        cost = 0
#        pred = Block(mb)
        # process each submacroblock and get the cost
#        for n in aptree:
          # if 8x8, then you'd do another split on each quadrant
          
#          cost,mode += process(n,pred)
#        if cost < min_cost:
#          best_inter_pred[:,:,:] = pred
#          min_cost = cost 



