from read_yuv import *
from intra import *
from config import *
from params import *
from quant import *
from transform import *
from partition import *
from cost_functions import *
from cola.block import *
from cola.parallel_support import *

# I think the JM implementation is buggy here. It doesn't inv. quantize the AC coeffs?
def xform_quant_luma_16x16(mb, intra_coded_mb):
  residual = mb - intra_coded_mb
  # result of transform and quantize (pre-entropy coding)
  coded = Block(residual)
  mb_reconstruction = Block(residual)
  mb_reconstruction[:,:,:] = 0
  residual_split = split_16x16_to_4x4(residual)[0]
  coded_split = split_16x16_to_4x4(coded)[0]
  for resid_4x4,coded_4x4 in zip(residual_split,coded_split):
    forward4x4(resid_4x4,coded_4x4)
  ### DC ###
  # gather the DCs
  DCs = coded[0,::4,::4]  
  # do second pass on the DCs
  coded_DCs = Block(DCs)
  hadamard4x4(DCs,coded_DCs)
  # now quantize the DCs
  nonzero = quant_dc4x4_normal(coded_DCs, QP)
  cola_debug(coded_DCs)
  assert False
  if nonzero:
    # ixform DCs
    ihadamard4x4(coded_DCs, mb_reconstruction[0,::4,::4])
    print(mb_reconstruction)
    assert False
    # iquant DCs
    for i in mb_reconstruction[0,::4,::4]:
      q = rshift_rnd_sf((i() * iscale) << qp_per_matrix[QP], 6)
      i[ALL] = rshift_rnd_sf((i() * iscale) << qp_per_matrix[QP], 6)
    print(mb_reconstruction[0,::4,::4])
  else:
    mb_reconstruction[0,::4,::4] = 0

  ### AC AND IXFORM ###
  recons_split = split_16x16_to_4x4(mb_reconstruction)[0]
  for coded_4x4,recons_4x4 in zip(coded_split,recons_split):
    # quant 4x4 ac block
    quant_ac4x4_normal(coded_4x4, QP)
    # inverse quantize
    citer = iter(recons_4x4)
    next(citer) # skip this DC
    for c in citer:
      c[ALL] = rshift_rnd_sf((c() * iscale) << qp_per_matrix[QP], 6)
    # inverse transform
    cola_debug(recons_4x4)
    assert False
    xout = Block(recons_4x4)
    inverse4x4(recons_4x4, xout)
    recons_4x4[:,:,:] = xout
    cola_debug(recons_4x4)

  # at this point, mb_reconstruction contains the appropriate dequantized AC and DCs
  # now we need to...
#  # separate residual into 4x4 blocks
#  resid_4x4 = split_16x16_to_4x4(residual)[0]
#  # create the reconstruction
#  recons = Block(mb)
#  # separate that
#  recons_4x4 = split_16x16_to_4x4(recons)[0]
#  for inv,res,rec in zip(ac_inv,resid_4x4,recons_4x4):
#    # run the final mb_reconstruction on it
#    ixform = Block(inv)
#    mb_reconstruction4x4(inv,ixform)
#    # add it back to the residual and make the recons
#    rec[0,:,:] = res + ixform
  return mb_reconstruction,coded

y_frames,u_frames,v_frames = ingest_yuv_420_interleaved_all(False)

y_cgrid = y_frames.base.cgrid
u_cgrid = u_frames.base.cgrid
v_cgrid = v_frames.base.cgrid

# no slices
# Y
for idx,f in enumerate(range(1)):#range(nframes)):
  y_frame = y_frames[f,:,:]
  for r in range(0,y_frame.dims(1),16):
    for c in range(0,y_frame.dims(2),16):
      mb = y_frame[0,r:r+16,c:c+16]
      
      ### 16x16 Intra-Prediction 
      cola_debug(mb)
      intra_16x16_pred_m0 = intra_16x16_luma_m0(mb)
      intra_16x16_pred_m1 = intra_16x16_luma_m1(mb)
      intra_16x16_pred_m2 = intra_16x16_luma_m2(mb)
      intra_16x16_pred_m3 = intra_16x16_luma_m3(mb)

      costs_16x16 = [INT_MAX] * 4
      
      if intra_16x16_pred_m0:
        recons,quant = xform_quant_luma_16x16(mb, ~intra_16x16_pred_m0)
        cost = sad(mb,recons)
        costs_16x16[0] = cost
      if intra_16x16_pred_m1:
        recons,quant = xform_quant_luma_16x16(mb, ~intra_16x16_pred_m1)
        cost = sad(mb,recons)
        costs_16x16[1] = cost
      if intra_16x16_pred_m2:
        recons,quant = xform_quant_luma_16x16(mb, ~intra_16x16_pred_m2)
        cost = sad(mb,recons)
        costs_16x16[2] = cost
      if intra_16x16_pred_m3:
        recons,quant = xform_quant_luma_16x16(mb, ~intra_16x16_pred_m3)
        cost = sad(mb,recons)
        costs_16x16[3] = cost
      
      cola_debug(costs_16x16)
      
