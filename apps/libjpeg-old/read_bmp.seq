from errors import *
from cmyk import *
from config import *
from constants import *
from cola.iter_utils import *
from cola.block import *
from cola.bitseq import *

alpha_index = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1]

@extend
class int:
  def is_ext_rgb(self) -> bool:
    return self == JCS_RGB or (self >= JCS_EXT_RGB and self <= JCS_EXT_ARGB)

def read_colormap(fd: File, colormap: Block[SAMPLE], mapentrysize: int, in_color_space: int) -> int:
  gray = True
  if mapentrysize == 3:
    for i in range(colormap.dims()[1]):
      colormap[2,i] = SAMPLE(fd.read(1))
      colormap[1,i] = SAMPLE(fd.read(1))
      colormap[0,i] = SAMPLE(fd.read(1))
      if colormap[2,i] != colormap[1,i] or colormap[1,i] != colormap[0,i]:
        gray = False
  elif mapentrysize == 4:
    for i in range(colormap.dims()[1]):
      colormap[2,i] = SAMPLE(fd.read(1))
      colormap[1,i] = SAMPLE(fd.read(1))
      colormap[0,i] = SAMPLE(fd.read(1))
      fd.read(1)
      if colormap[2,i] != colormap[1,i] or colormap[1,i] != colormap[0,i]:
        gray = False
  else:
    raise LoadImageError('Bad cmap')
  if in_color_space == JCS_UNKNOWN and gray:
    in_color_space = JCS_GRAYSCALE
  if in_color_space == JCS_GRAYSCALE and not gray:
    raise LoadImageError('Bad colorspace')
  return in_color_space

def read_bmp_bits(str_bits: str, nbits: int, offset: int) -> int:
  return int(BitSeq(str_bits[offset:], nbits))

class bmp_info:
  map_entry_size: int
  biWidth: int
  biHeight: int
  biPlanes: int
  biCompression: int
  biXPelsPerMeter: int
  biYPelsPerMeter: int
  biClrUsed: int
  bits_per_pixel: int
  x_density: int
  y_density: int
  density_unit: int
  colormap: Optional[Block[SAMPLE]] = None
  in_color_space: int
  input_components: int
  data_precision: int
  image_width: int
  image_height: int
  use_inversion_array: bool
  # if use_inversion array, this gets preloaded
  whole_image: Optional[Block[SAMPLE]] = None
  # holds the current row of interleaved pixel components
  iobuffer: Optional[Block[SAMPLE]] = None
  # holds the color converted pixels for a row
  buffer: Optional[Block[SAMPLE]] = None

  def __init__(self):
    self.map_entry_size = 0
    self.biWidth = 0
    self.biHeight = 0
    self.biPlanes = 0
    self.biCompression = 0
    self.biXPelsPerMeter = 0
    self.biYPelsPerMeter = 0
    self.biClrUsed = 0
    self.bits_per_pixel = 0
    self.x_density = 1
    self.y_density = 1
    self.density_unit = 0
    self.input_components = -1
    self.in_color_space = JCS_UNKNOWN
    self.data_precision = BITS_IN_SAMPLE
    self.image_width = -1
    self.image_height = -1
    self.use_inversion_array = False

def read_bmp_header(fd: File, _in_color_space: int, use_inversion_array: bool) -> bmp_info:

  bmp_header = fd.read(14)  
  if bmp_header == '':
    raise LoadImageError('Bitmap header missing')
  if read_bmp_bits(bmp_header, 16, 0) != 0x4D42:
    raise LoadImageError('Not bitmap')
  bf_off_bits = read_bmp_bits(bmp_header, 32, 10)
  bmp_header = fd.read(4)
  if bmp_header == '':
    raise LoadImageError('Bitmap header missing')
  header_size = read_bmp_bits(bmp_header, 32, 0)
  if header_size < 12 or header_size > 64:
    raise LoadImageError('Bad header')
  bmp_header = fd.read(header_size-4)
  info = bmp_info()
  info.use_inversion_array = use_inversion_array
  info.in_color_space = _in_color_space
  if header_size == 12:
    raise NotImplementedError()
    info.biWidth = read_bmp_bits(bmp_header, 16, 0)
    info.biHeight = read_bmp_bits(bmp_header, 16, 2) 
    info.biPlanes = read_bmp_bits(bmp_header, 16, 4) 
    info.bits_per_pixel = read_bmp_bits(bmp_header, 16, 6)
  elif header_size == 40 or header_size == 64:
    info.biWidth = read_bmp_bits(bmp_header, 32, 0)
    info.biHeight = read_bmp_bits(bmp_header, 32, 4)
    info.biPlanes = read_bmp_bits(bmp_header, 16, 8)
    info.bits_per_pixel = read_bmp_bits(bmp_header, 16, 10)
    info.biCompression = read_bmp_bits(bmp_header, 32, 12)
    info.biXPelsPerMeter = read_bmp_bits(bmp_header, 32, 20)
    info.biYPelsPerMeter = read_bmp_bits(bmp_header, 32, 24)
    info.biClrUsed = read_bmp_bits(bmp_header, 32, 28)
    if info.bits_per_pixel == 8:
      info.map_entry_size = 3
    elif info.bits_per_pixel != 24 and info.bits_per_pixel != 32:
      raise LoadImageError("Bad depth")
    if info.biCompression != 0:
      raise LoadImageError("biCompression")
    if info.biXPelsPerMeter > 0 and info.biYPelsPerMeter > 0:
      info.x_density = info.biXPelsPerMeter // 100
      info.y_density = info.biYPelsPerMeter // 100
      info.density_unit = 2
  else:
    raise LoadImageError("Bad header")
  if info.biWidth <= 0 or info.biHeight <= 0:
    raise LoadImageError("BMP empty")
  if info.biPlanes != 1:
    raise LoadImageError("Bad planes")
  bPad = bf_off_bits - (header_size + 14)
  if info.map_entry_size > 0:
    if info.biClrUsed <= 0:
      info.biClrUsed = 256
    elif info.biClrUsed > 256:
      raise LoadImageError("badcmap")
    info.colormap = Block[SAMPLE](3, info.biClrUsed)
    info.in_color_space = read_colormap(fd, info.colormap, info.map_entry_size, info.in_color_space)
    bPad -= info.biClrUsed * info.map_entry_size
  if bPad < 0:
    raise LoadImageError("Bad header")
  bPad -= 1
  while bPad >= 0:
    fd.read(1)
    bPad -= 1
  if info.bits_per_pixel == 8:
    raise NotTestedError()
    if info.in_color_space == JCS_UNKNOWN:
      info.in_color_space = JCS_EXT_RGB
    if info.in_color_space.is_ext_rgb():
      info.input_components = rgb_pixelsize[info.in_color_space]
    elif info.in_color_space == JCS_GRAYSCALE:
      info.input_components = 1
    elif info.in_color_space == JCS_CMYK:
      info.input_components = 4
    else:
      raise LoadImageError('Bad colorspace')
  elif info.bits_per_pixel == 24:
    if info.in_color_space == JCS_UNKNOWN:
      info.in_color_space = JCS_EXT_BGR
    if info.in_color_space.is_ext_rgb():
      info.input_components = rgb_pixelsize[info.in_color_space]
    elif info.in_color_space == JCS_CMYK:
      info.input_components = 4
    else:
      raise LoadImageError('Bad colorspace')
  elif info.bits_per_pixel == 32:
    raise NotTestedError()
    if info.in_color_space == JCS_UNKNOWN:
      info.in_color_space = JCS_EXT_BGRA
    if info.in_color_space.is_ext_rgb():
      info.input_components = rgb_pixelsize[info.in_color_space]
    elif info.in_color_space == JCS_CMYK:
      info.input_components = 4
    else:
      raise LoadImageError('Bad colorspace')
  else:
    raise LoadImageError('Bad depth')
  while row_nbytes & 3 != 0:
    row_nbytes += 1
  if use_inversion_array:    
    raise NotTestedError()
    info.whole_image = Block[SAMPLE](info.biHeight, info.biWidth, info.input_components)  
  else:
    info.iobuffer = Block[SAMPLE](info.biWidth, info.input_components)
  if u64(info.biWidth) * u64(info.input_components) > u64(0xFFFFFFFF):
    raise LoadImageError('Width overflow')
  info.buffer = Block[SAMPLE](info.biWidth, info.input_components)
  info.data_precision = 8
  info.image_width = info.biWidth
  info.image_height = info.biHeight
  return info

def get_8bit_row(info: bmp_info, fd: File):
  raise NotImplementedError()

def get_32bit_row(info: bmp_info, fd: File):
  raise NotImplementedError()

def get_24bit_row(info: bmp_info, fd: File) -> int:
  if info.use_inversion_array:
    raise NotImplementedError()
  else:
    nelems = info.iobuffer.nunits()
    # read into underlying buffer
    if fd.read(nelems, 1, info.iobuffer) != nelems:
      raise LoadImageError('read error')    
    if info.in_color_space == JCS_EXT_BGR:
      # no color conversion needed
      info.buffer[:,:] = info.iobuffer
    elif info.in_color_space == JCS_CMYK:
      raise NotTestedError()
      Rs = info.iobuffer[:,0]
      Gs = info.iobuffer[:,1]
      Bs = info.iobuffer[:,2]
      outCs = info.buffer[:,0]
      outMs = info.buffer[:,1]
      outYs = info.buffer[:,2]
      outKs = info.buffer[:,3]
      for r,g,b,c,m,y,k in scan(Rs, Gs, Bs, outCs, outMs, outYs, outKs):
        rgb_to_cmyk(r(),g(),b(),c,m,y,k)
    else:
      raise NotTestedError()
      rindex = rgb_red[info.in_color_space]
      gindex = rgb_green[info.in_color_space]
      bindex = rgb_blue[info.in_color_space]
      aindex = alpha_index[info.in_color_space]
      if aindex >= 0:
        info.buffer[:,bindex] = info.iobuffer[:,0]
        info.buffer[:,gindex] = info.iobuffer[:,1]
        info.buffer[:,rindex] = info.iobuffer[:,2]
        info.buffer[:,aindex] = SAMPLE(0xFF)
      else:
        info.buffer[:,bindex] = info.iobuffer[:,0]
        info.buffer[:,gindex] = info.iobuffer[:,1]
        info.buffer[:,rindex] = info.iobuffer[:,2]       

def read_bmp_data(info: bmp_info, fd: File, invert: bool):
  # reads 1 row of pixel comps at a time
  info.whole_image = Block[SAMPLE](info.image_height, info.image_width, info.input_components)
  # bmp rows (input comps * width) are 4 byte aligned 
  for i in range(info.image_height):
    if info.bits_per_pixel == 8:
      get_8bit_row(info, fd)
    elif info.bits_per_pixel == 24:
      get_24bit_row(info, fd)
    else:
      get_32bit_row(info, fd)
    # copy the contents of info.buffer to info.whole_image
    if invert:
      info.whole_image[info.image_height - i - 1, :, :] = info.buffer
    else:
      info.whole_image[i, :, :]
