from turbojpeg import *
from jpeglib import *
from errors import *
from config import *
from moreconstants import *
from structs import *
from colorconv import *
from cola.iter_utils import *

alpha_index = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1]

def read_colormap(fd: File, cmaster: CompressMaster, mapentrysize: int):
  gray = True
  if mapentrysize == 3:
    for i in range(cmaster.bmpinfo.colormap.dims()[1]):
      cmaster.bmpinfo.colormap[2,i] = JSAMPLE(fd.read(1))
      cmaster.bmpinfo.colormap[1,i] = JSAMPLE(fd.read(1))
      cmaster.bmpinfo.colormap[0,i] = JSAMPLE(fd.read(1))
      if cmaster.bmpinfo.colormap[2,i] != cmaster.bmpinfo.colormap[1,i] or cmaster.bmpinfo.colormap[1,i] != cmaster.bmpinfo.colormap[0,i]:
        gray = False
  elif mapentrysize == 4:
    for i in range(cmaster.bmpinfo.colormap.dims()[1]):
      cmaster.bmpinfo.colormap[2,i] = JSAMPLE(fd.read(1))
      cmaster.bmpinfo.colormap[1,i] = JSAMPLE(fd.read(1))
      cmaster.bmpinfo.colormap[0,i] = JSAMPLE(fd.read(1))
      fd.read(1)
      if cmaster.bmpinfo.colormap[2,i] != cmaster.bmpinfo.colormap[1,i] or cmaster.bmpinfo.colormap[1,i] != cmaster.bmpinfo.colormap[0,i]:
        gray = False
  else:
    raise LoadImageError('Bad cmap')
  if cmaster.cinfo.in_color_space == JCS_UNKNOWN and gray:
    cmaster.cinfo.in_color_space = JCS_GRAYSCALE
  if cmaster.cinfo.in_color_space == JCS_GRAYSCALE and not gray:
    raise LoadImageError('Bad colorspace')

def start_input_bmp(cmaster: CompressMaster, fd: File):
  cmaster.bmpinfo = bmp_source_struct()
  bmpfileheader = fd.read(14)  
  if bmpfileheader == '':
    raise LoadImageError('Bitmap header missing')
  if BitSeq(bmpfileheader, 16) != BitSeq(0x4D42, 16):
    raise LoadImageError('Not bitmap')
  bfOffBits = u32(BitSeq(bmpfileheader[10:], 32))
  bmpinfoheader = fd.read(4)
  if bmpinfoheader == '':
    raise LoadImageError('Bitmap info header missing')
  headerSize = int(BitSeq(bmpinfoheader, 32))
  if headerSize < 12 or headerSize > 64:
    raise LoadImageError('Bad info header')
  bmpinfoheader = fd.read(headerSize-4)
  mapentrysize = 0
  biWidth = 0
  biHeight = 0
  biPlanes = u16(0)
  biCompression = u32(0)
  biXPelsPerMeter = 0
  biYPelsPerMeter = 0
  biClrUsed = u32(0)
  if headerSize == 12:
    biWidth = int(BitSeq(bmpinfoheader, 16))
    biHeight = int(BitSeq(bmpinfoheader[2:], 16))
    biPlanes = u16(BitSeq(bmpinfoheader[4:], 16))
    cmaster.bmpinfo.bits_per_pixel = int(BitSeq(bmpinfoheader[6:], 16))
    raise NotImplementedError()
  elif headerSize == 40 or headerSize == 64:
    biWidth = int(BitSeq(bmpinfoheader, 32))
    biHeight = int(BitSeq(bmpinfoheader[4:], 32))
    biPlanes = u16(BitSeq(bmpinfoheader[8:], 16))
    cmaster.bmpinfo.bits_per_pixel = int(BitSeq(bmpinfoheader[10:], 16))
    biCompression = u32(BitSeq(bmpinfoheader[12:], 32))
    biXPelsPerMeter = int(BitSeq(bmpinfoheader[20:], 32))
    biYPelsPerMeter = int(BitSeq(bmpinfoheader[24:], 32))
    biClrUsed = u32(BitSeq(bmpinfoheader[28:], 32))
    if cmaster.bmpinfo.bits_per_pixel == 8:
      # TODO traceinfo
      mapentrysize = 3
    elif cmaster.bmpinfo.bits_per_pixel == 24 or cmaster.bmpinfo.bits_per_pixel == 32:
      # TODO traceinfo
      pass
    else:
      raise LoadImageError("Bad depth")
    if biCompression != u32(0):
      raise LoadImageError("biCompression")
    if biXPelsPerMeter > 0 and biYPelsPerMeter > 0:
      cmaster.cinfo.X_density = u16(biXPelsPerMeter//100)
      cmaster.cinfo.Y_density = u16(biYPelsPerMeter//100)
      cmaster.cinfo.density_unit = 2
  else:
    raise LoadImageError("Bad header")
  if biWidth <= 0 or biHeight <= 0:
    raise LoadImageError("BMP empty")
  if biPlanes != u16(1):
    raise LoadImageError("Bad planes")
  bPad = int(bfOffBits - u32(headerSize + 14))
  if mapentrysize > 0:
    if biClrUsed <= u32(0):
      biClrUsed = u32(256)
    elif biClrUsed > u32(256):
      raise LoadImageError("badcmap")
    cmaster.bmpinfo.colormap = Block[JSAMPLE](3, int(biClrUsed))
    read_colormap(fd, cmaster,  mapentrysize)
    bPad -= int(biClrUsed * u32(mapentrysize))
  if bPad < 0:
    raise LoadImageError("Bad header")
  bPad -= 1
  while bPad >= 0:
    fd.read(1)
    bPad -= 1
  row_width = u32(0)
  if cmaster.bmpinfo.bits_per_pixel == 8:
    if cmaster.cinfo.in_color_space == JCS_UNKNOWN:
      cmaster.cinfo.in_color_space = JCS_EXT_RGB
    if cmaster.cinfo.in_color_space.is_ext_rgb():
      cmaster.cinfo.input_components = rgb_pixelsize[cmaster.cinfo.in_color_space]
    elif cmaster.cinfo.in_color_space == JCS_GRAYSCALE:
      cmaster.cinfo.input_components = 1
    elif cmaster.cinfo.in_color_space == JCS_CMYK:
      cmaster.cinfo.input_components = 4
    else:
      raise LoadImageError('Bad colorspace')
    row_width = u32(biWidth)
  elif cmaster.bmpinfo.bits_per_pixel == 24:
    if cmaster.cinfo.in_color_space == JCS_UNKNOWN:
      cmaster.cinfo.in_color_space = JCS_EXT_BGR
    if cmaster.cinfo.in_color_space.is_ext_rgb():
      cmaster.cinfo.input_components = rgb_pixelsize[cmaster.cinfo.in_color_space]
    elif cmaster.cinfo.in_color_space == JCS_CMYK:
      cmaster.cinfo.input_components = 4
    else:
      raise LoadImageError('Bad colorspace')
    row_width = u32(biWidth * 3)
  elif cmaster.bmpinfo.bits_per_pixel == 32:
    if cmaster.cinfo.in_color_space == JCS_UNKNOWN:
      cmaster.cinfo.in_color_space = JCS_EXT_BGRA
    if cmaster.cinfo.in_color_space.is_ext_rgb():
      cmaster.cinfo.input_components = rgb_pixelsize[cmaster.cinfo.in_color_space]
    elif cmaster.cinfo.in_color_space == JCS_CMYK:
      cmaster.cinfo.input_components = 4
    else:
      raise LoadImageError('Bad colorspace')
    row_width = u32(biWidth * 4)    
  else:
    raise LoadImageError('Bad depth')
  while row_width & u32(3) != u32(0):
    row_width += u32(1)
  if cmaster.bmpinfo.use_inversion_array:    
    raise NotImplementedError()
  else:
    cmaster.bmpinfo.iobuffer = Block[u8](int(row_width))
  if u64(biWidth * cmaster.cinfo.input_components) > BitSeq(0xFFFFFFFF, 64):
    raise LoadImageError('Width overflow')
  # This is different from libjpeg-turbo. They have biWidth instead of row width, but that can be smaller than 
  # row-width, which makes memcpy copy more bytes than the size of the destination
  cmaster.bmpinfo.buffer = Block[JSAMPLE](cmaster.cinfo.input_components, int(row_width) // cmaster.cinfo.input_components)#biWidth * cmaster.cinfo.input_components)
  cmaster.cinfo.data_precision = 8
  cmaster.cinfo.image_width = u32(biWidth)
  cmaster.cinfo.image_height = u32(biHeight)

def get_8bit_row(cmaster: CompressMaster, fd: File) -> int:
  raise NotImplementedError()

def get_24bit_row(cmaster: CompressMaster, fd: File) -> int:
  print('in get_24bit_row')
  if cmaster.bmpinfo.use_inversion_array:
    raise NotImplementedError()
  else:
    bmpinfo = cmaster.bmpinfo
    rwidth = bmpinfo.iobuffer.dims()[0]
    # This check may actually be done in the seq C impl of file read, but I'm not sure
    if fd.read(rwidth, 1, bmpinfo.iobuffer) != rwidth:
      raise LoadImageError('read error')
    cinfo = cmaster.cinfo
    if cinfo.in_color_space == JCS_EXT_BGR:
      print(bmpinfo.buffer.dims())
      print(bmpinfo.iobuffer.dims())
      bmpinfo.buffer.reshape(rwidth)[:] = bmpinfo.iobuffer
      print(bmpinfo.buffer)
    elif cinfo.in_color_space == JCS_CMYK:
      raise NotTestedError()
      Rs = bmpinfo.iobuffer[::3]
      Gs = bmpinfo.iobuffer[1::3]
      Bs = bmpinfo.iobuffer[2::3]
      outCs = bmpinfo.buffer[0,::4]
      outMs = bmpinfo.buffer[0,1::4]
      outYs = bmpinfo.buffer[0,2::4]
      outKs = bmpinfo.buffer[0,3::4]
      for r,g,b,c,m,y,k in scan(Rs, Gs, Bs, outCs, outMs, outYs, outKs):
        rgb_to_cmyk(r(),g(),b(),c,m,y,k)
    else:
      raise NotTestedError()
      rindex = rgb_red[cinfo.in_color_space]
      gindex = rgb_green[cinfo.in_color_space]
      bindex = rgb_blue[cinfo.in_color_space]
      aindex = alpha_index[cinfo.in_color_space]
      if aindex >= 0:
        bmpinfo.buffer[0,bindex::3] = bmpinfo.iobuffer[::3]
        bmpinfo.buffer[0,gindex::3] = bmpinfo.iobuffer[1::3]
        bmpinfo.buffer[0,rindex::3] = bmpinfo.iobuffer[2::3]
        bmpinfo.buffer[0,aindex::3] = JSAMPLE(0xFF)
      else:
        bmpinfo.buffer[0,bindex::3] = bmpinfo.iobuffer[::3]
        bmpinfo.buffer[0,gindex::3] = bmpinfo.iobuffer[1::3]
        bmpinfo.buffer[0,rindex::3] = bmpinfo.iobuffer[2::3]        
  return 1

def get_32bit_row(cmaster: CompressMaster, fd: File) -> int:
  raise NotImplementedError()

def jinit_read_bmp(cmaster: CompressMaster, use_inversion_array: bool):
  cmaster.bmpinfo = bmp_source_struct()
  cmaster.bmpinfo.use_inversion_array = use_inversion_array
  cmaster.filetype = 'BMP'
