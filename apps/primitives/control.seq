from transform import *
from cola.block import *
from common import *
from intra import *
from quant import *

def xform_quant_luma_16x16(mb, pred, fd):
  residual = mb - pred
  transformed = Block(residual)
  # first transform
  for i in range(0,16,4):
    for j in range(0,16,4):
      forward4x4(residual[0,i:i+4,j:j+4], transformed[0,i:i+4,j:j+4])
  # gather the DCs and transform them
  DCs = transformed[0,::4,::4]
  transformed_DCs = Block(DCs)
  hadamard4x4(DCs, transformed_DCs)
  # quantize the DCs
  quant_dc4x4_normal(transformed_DCs, QP)
  fd.write(str(transformed_DCs))
  

# do prediction, call the transform loop, get the costs
def pred_luma_16x16(mb, fd):
  pred_16x16_vertical = Block(mb)
  pred_16x16_horizontal = Block(mb)
  pred_16x16_DC = Block(mb)
  pred_16x16_planar = Block(mb)
  costs = make_cost_array(4)
  did_vertical = intra_16x16_luma_vertical(mb, pred_16x16_vertical)
  did_horizontal = intra_16x16_luma_horizontal(mb, pred_16x16_horizontal)
  intra_16x16_luma_DC(mb, pred_16x16_DC)
  did_planar = intra_16x16_luma_planar(mb, pred_16x16_planar)
  if did_vertical:
    xform_quant_luma_16x16(mb, pred_16x16_vertical, fd)
  if did_horizontal:
    xform_quant_luma_16x16(mb, pred_16x16_horizontal, fd)
  xform_quant_luma_16x16(mb, pred_16x16_DC, fd)
  if did_planar:
    xform_quant_luma_16x16(mb, pred_16x16_planar, fd)  
  # compute fake costs
#  if did_vertical:
#    s = 0
#    for p in pred_16x16_vertical:
#      s += p()
#    costs[0] = s
#  if did_horizontal:
#    s = 0
#    for p in pred_16x16_horizontal:
#      s += p()
#    costs[1] = s
#  s = 0
#  for p in pred_16x16_DC:
#    s += p()
#  costs[2] = s
#  if did_planar:
#    s = 0
#    for p in pred_16x16_planar:
#      s += p()
#    costs[3] = s

