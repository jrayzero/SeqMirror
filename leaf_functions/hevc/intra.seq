from cola.block import *

# TODO availability, substitution
def check_availability(log2_width, blk, slice_info: Block[int,2]):
  r,c = blk.origin()
  width = 1 << log2_width 
  my_slice = slice_info(r,c)
  up_available = r > 0 and my_slice == slice_info(r-1,c)
  left_available = c > 0 and my_slice == slice_info[blk[0,-1]]()
  up_right_available = blk[-1,:2*width].is_in_bounds() and \
                       my_slice == slice_info[blk[-1,0]]() and \
                       my_slice == slice_info[blk[-1,width]]()
  up_left_available = blk_8x8[-1,-1].is_in_bounds() and \
                      my_slice == slice_info[blk[-1,-1]]
  bottom_left_available = blk[:2*width,-1].is_in_bounds() and \
                       my_slice == slice_info[blk[0,-1]]() and \
                       my_slice == slice_info[blk[width,-1]]()

  return up_available,left_available,up_right_available, up_left_available, bottom_left_available


def get_top_ref(log2_width: int, blk, slice_info: Block[int,2]):
  r,c = blk.origin()
  my_slice = slice_info(r,c)
  # need 2 * log2_width + 1 (+ 1 is for the negative element)
  up_available, _, up_right_available, up_left_available, _ = check_availability(log2_width, blk, slice_info)
  width = 1 << log2_width

  ref_above = Block[int](width * 2 + 1)

  if up_left_available:
    # copy ref(-1, -1) into ref_above
  if up_available:
    # copy ref[-1,:] into front of reb_above
  if up_right_available:
    # copy starting at ref[-1,width]

  # otherwise substitute

  return ref_above

def get_left_ref(log2_width: int, blk, slice_info: Block[int,2]):
  r,c = blk.origin()
  my_slice = slice_info(r,c)
  # need 2 * log2_width + 1 (+ 1 is for the negative element)
  _, left_available, _, up_left_available, bottom_left_available = check_availability(log2_width, blk, slice_info)
  width = 1 << log2_width

  ref_left = Block[int](width * 2 + 1)

  if up_left_available:
    # copy ref(-1, -1) into ref_above
  if up_available:
    # copy ref[:,-1] into front of reb_above
  if up_right_available:
    # copy starting at ref[width, -1]

  # otherwise substitute

  return ref_left

# intra prediction mode 0
# there is a hand optimized version in kvazaar
def intra_luma_planar(log2_width, ref_above, ref_left, mb):
  width = 1 << log2_width
  pred = Block(mb)

  # can actually work with just blk[-1,:] and blk[:,-1]
  top_right = ref_above[width + 1]
  bottom_left = ref_left[width + 1]

  # unoptimized version - similar to the code in Sze's book
  for y in range(width):
    for x in range(width):
      hor = (width - 1 - x) * ref_left[y + 1] + (x + 1) * top_right
      ver = (width - 1 - y) * ref_above[x + 1] + (y + 1) * bottom_left
      pred[0, y, x] = (hor + ver + width) >> (log2_width + 1)

  return pred
  
# intra prediction mode 1
def intra_luma_dc(log2_width, ref_above, ref_left, mb):
  width = 1 << log2_width

  s = 0
  for i in range(width):
    s += ref_above[i] + ref_left[i]

  pred = Block(mb)
  pred[:,:,:] = (s + width) >> log2_width

  return pred

# transpose a block
def transpose(blk, width):
  pass

def intra_luma_angular(mode, log2_width, ref_above, ref_left, mb):
  # symmetric
  abs_angle_param_A = [0, 2, 5, 9, 13, 17, 21, 26, 32]
  abs_angle_param_B = [0, 4096, 1638, 910, 630, 482, 390, 315, 256]

  width = 1 << log2_width
  pred = Block(mb)

  vertical = mode >= 18
  # displacement from mode corresponding to A = 0
  mode_disp = 0
  if vertical:
    mode_disp = mode - 26
  else:
    mode_disp = 10 - mode

  angle_param_A = 0
  if (mode_disp < 0):
    angle_param_A = -abs_angle_param_A[abs(mode_disp)]
  else:
    angle_param_A = abs_angle_param_A[abs(mode_disp)]

  ref_main = Block[int](2 * width + 1, 1)
  # just instantiate
  ref_side = Block[int](2 * width + 1, 1)

  if (vertical):
    ref_main = ref_above
    ref_side = ref_left
  else:
    ref_main = ref_left
    ref_side = ref_above

  if (angle_param_A < 0):
    tmp_ref[width,:] = ref_main

    # set values from 0 to width - 1
    angle_param_B = abs_angle_param_B[abs(mode_disp)]
    most_negative_index = (width * angle_param_A) >> 5
    for i in range(-2, most_negative_index, -1):
        tmp_ref[width + i, 0] = ref_side[-1 + ((i * angle_param_B) + 128) >> 8, 0]

    ref_main = tmp_ref[width,:]

  if (angle_param_A != 0): #interpolation needed/not vertical or horizontal
    i = 0
    for y in range(width):
      int_disp = (y + 1) * angle_param_A >> 5
      frac_disp = ((y + 1) * angle_param_A) & 31

      if frac_disp: # 1/32 (linear filtering)
        for x in range(width):
          ref_1 = ref_main(x + int_disp, 0)
          ref_2 = ref_main(x + int_disp + 1, 0)
          pred[y, x] = ((32 - frac_disp) * ref_1 + frac_disp * ref_2 + 16) >> 5
      else: # copy if reference exists
        for x in range(width):
          pred[y, x] = ref_main[x + int_disp,:]
  else:
    for y in range(width):
      for x in range(width):
        pred[y, x] = ref_main(x, 0) 

  if (not vertical):
    transpose(pred, width)

  return pred


'''
Kvazaar Reference:
static void intra_post_process_angular(
  unsigned width,
  unsigned stride,
  const kvz_pixel *ref,
  kvz_pixel *block)
{
  kvz_pixel ref2 = ref[0];
  for (unsigned i = 0; i < width; i++) {
    kvz_pixel val = block[i * stride];
    kvz_pixel ref1 = ref[i + 1];
    block[i * stride] = CLIP_TO_PIXEL(val + ((ref1 - ref2) >> 1));
  }
}
'''
def intra_post_process_angular(width: int, stride: int, ref, block):
  pass #TODO

# maybe more ideal way to do angular intra prediction:
def _im_intra_luma_angular(mode, log2_width, ref_above, ref_left, mb):
  # useful functions?
  # get ref_main function would be helpful (an array with the pixels along the path)
  pass
