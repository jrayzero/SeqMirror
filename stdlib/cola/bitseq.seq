# TODO allow packing bits > 32 by breaking it up into different
# sequences. 

class Bits:
  # holds bytes to be written to a file
  output_buffer: Ptr[byte]
  # number of bytes in output_buffer
  output_sz: int
  # holds temporary bit sequence. A max of 32 bits
  # can be packed on at a time. Whenever it gets 
  # above 32 bits, 1 byte at a time is moved to the
  # output buffer
  accum_buffer: UInt[64]
  # number of bits in the accum_buffer
  accum_sz: int
  fd: File
  
  def __init__(self):
    assert False 

  def __init__(self, fd: File):
    self.output_buffer = Ptr[byte](64) #[byte(0)] * 64
    self.output_sz = 0
    self.accum_buffer = UInt[64](0)
    self.accum_sz = 0
    self.fd = fd

  # pack towards LSB (its always right aligned tho starting at the MSB)
  def pack(self, val: int, nbits, stuff: bool = False):
    assert nbits <= 32
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if(jpeg_stuff_zero_byte = stuff)

  def pack[T: int](self, val: Int[T], nbits, stuff: bool = False):
    assert nbits <= 32
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if(jpeg_stuff_zero_byte = stuff)

  def pack[T: int](self, val: UInt[T], nbits, stuff: bool = False):
    assert nbits <= 32
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if(jpeg_stuff_zero_byte = stuff)

  def pack[T: int](self, val: Int[T], stuff: bool = False):
    assert T <= 32
    nbits = T
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if(jpeg_stuff_zero_byte = stuff)

  def pack[T: int](self, val: UInt[T], stuff: bool = False):
    assert T <= 32
    nbits = T
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if(jpeg_stuff_zero_byte = stuff)

  # see if we need to move bits from accum_buffer to output_buffer
  def put_if(self, bound: int = 32, jpeg_stuff_zero_byte: bool = False):
    # need to flush to no more than 32 bits
    while self.accum_sz > bound:
      # we move 1 byte at a time from MSB to LSB
      bt = (self.accum_buffer >> UInt[64](56)) & UInt[64](0xFF)
      self.output_buffer[self.output_sz] = byte(bt)
      self.output_sz += 1      
      self.accum_buffer <<= UInt[64](8) # get rid of the byte we just did
      self.accum_sz -= 8
      self.flush_output_if()
      # this is a special case for when the byte is 0xFF b/c that is usually a marker in JPEG,
      # so jpeg expects a zero byte after to differentiate it from a marker
      if bt == UInt[64](0xFF) and jpeg_stuff_zero_byte:
        self.output_buffer[self.output_sz] = byte(0)
        self.output_sz += 1
        self.flush_output_if()

  # see if we need to flush our output buffer to file
  def flush_output_if(self):
    if self.output_sz == 64:
      assert _C.fwrite(self.output_buffer, 1, 64, self.fd.fp) == 64
      self.output_sz = 0
      self.fd.flush()

  # force accum_buffer to be put to output_buffer, then flush output buffer
  def flush_all(self):
    # pack on 1s if we have partial bytes
    partial = self.accum_sz & 7
    if partial > 0:
      nbits = 8 - partial
      val = (1 << nbits) - 1
      uval = UInt[64](val)
      uval &= UInt[64]((1 << nbits)-1)
      self.accum_sz += nbits
      uval <<= UInt[64](64-self.accum_sz)
      uval |= self.accum_buffer
      self.accum_buffer = uval
    # flush everything to the output_buffer
    self.put_if(0)
    assert  _C.fwrite(self.output_buffer, 1, self.output_sz, self.fd.fp) == self.output_sz
    self.output_sz = 0
    self.fd.flush()

@extend
class UInt[N: int]:

  def __new__(val) -> UInt[N]:
    return UInt[N].process(val)

  def process[T: int](val: UInt[T]) -> UInt[N]:
    if T == N:
      return UInt[N].process_eq(val)
    elif T < N:
      return UInt[N].process_ext(val)
    else:
      return UInt[N].process_trunc(val)
  @llvm
  def process_trunc[T: int](val: UInt[T]) -> UInt[N]:
    %0 = trunc i{=T} %val to i{=N}
    ret i{=N} %0
  @llvm
  def process_ext[T: int](val: UInt[T]) -> UInt[N]:
    %0 = zext i{=T} %val to i{=N}
    ret i{=N} %0
  @llvm
  def process_eq[T: int](val: UInt[T]) -> UInt[N]:
    ret i{=N} %val

      
@extend
class byte:

  def __new__(val) -> byte:
    return byte.process(val)

  def process[T: int](val: Int[T]) -> byte:
    if T == 8:
      return byte.process_eq(val)
    elif T < 8:
      return byte.process_ext(val)
    else:
      return byte.process_trunc(val)

  def process[T: int](val: UInt[T]) -> byte:
    if T == 8:
      return byte.process_eq(val)
    elif T < 8:
      return byte.process_ext(val)
    else:
      return byte.process_trunc(val)      
  @llvm
  def process_trunc[T: int](val: Int[T]) -> byte:
    %0 = trunc i{=T} %val to i8
    ret i8 %0
  @llvm
  def process_trunc[T: int](val: UInt[T]) -> byte:
    %0 = trunc i{=T} %val to i8
    ret i8 %0
  @llvm
  def process_ext[T: int](val: Int[T]) -> byte:
    %0 = zext i{=T} %val to i8
    ret i8 %0
  @llvm
  def process_ext[T: int](val: UInt[T]) -> byte:
    %0 = zext i{=T} %val to i8
    ret i8 %0
  @llvm
  def process_eq[T: int](val: Int[T]) -> byte:
    ret i8 %val
  @llvm
  def process_eq[T: int](val: UInt[T]) -> byte:
    ret i8 %val

@extend
class File:
  
  # T = bytes
  def read_u[T: int](self) -> UInt[T*8]:
    self._ensure_open()
    buf = Ptr[byte](T)
    assert _C.fread(buf, 1, T, self.fp) == T
    self._errcheck("error in read")
    return buf.convert_u[T*8]()

  def read_s[T: int](self) -> Int[T*8]:
    self._ensure_open()
    buf = Ptr[byte](T)
    assert _C.fread(buf, 1, T, self.fp) == T
    self._errcheck("error in read")
    return buf.convert_s[T*8]()

@extend
class Ptr[T]:
  @llvm
  def convert_u[N: int](self) -> UInt[N]:
    %0 = bitcast {=T}* %self to i{=N}*
    %1 = load i{=N}, i{=N}* %0 
    ret i{=N} %1  
  @llvm
  def convert_s[N: int](self) -> Int[N]:
    %0 = bitcast {=T}* %self to i{=N}*
    %1 = load i{=N}, i{=N}* %0 
    ret i{=N} %1    

@extend
class float:
  def __new__(i) -> float:
    return float._to_float(i)
  @llvm
  def _to_float[N:int](i: UInt[N]) -> float:
    %0 = uitofp i{=N} %i to double
    ret double %0
  @llvm
  def _to_float[N:int](i: Int[N]) -> float:
    %0 = sitofp i{=N} %i to double
    ret double %0
