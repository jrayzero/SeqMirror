# TODO allow packing bits > 32 by breaking it up into different
# sequences. 

class Bits:
  # holds bytes to be written to a file
  output_buffer: Ptr[byte]
  # number of bytes in output_buffer
  output_sz: int
  # holds temporary bit sequence. A max of 32 bits
  # can be packed on at a time. Whenever it gets 
  # above 32 bits, 1 byte at a time is moved to the
  # output buffer
  accum_buffer: UInt[64]
  # number of bits in the accum_buffer
  accum_sz: int
  fd: File

  def __init__(self, fd: File):
    self.output_buffer = Ptr[byte](64)
    self.output_sz = 0
    self.accum_buffer = UInt[64](0)
    self.accum_sz = 0
    self.fd = fd

  # pack towards LSB (its always right aligned tho starting at the MSB)
  def pack(self, val: int, nbits):
    print(nbits)
    assert nbits <= 32
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if()

  def pack[T: int](self, val: Int[T], nbits):
    assert nbits <= 32
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if()

  def pack[T: int](self, val: UInt[T], nbits):
    assert nbits <= 32
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if()

  def pack[T: int](self, val: Int[T]):
    assert T <= 32
    nbits = T
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if()

  def pack[T: int](self, val: UInt[T]):
    assert T <= 32
    nbits = T
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if()

  # see if we need to move bits from accum_buffer to output_buffer
  def put_if(self, bound: int = 32, stuff_zero_byte: bool = False):
    # need to flush to no more than 32 bits
    while self.accum_sz > bound:
      # we move 1 byte at a time from MSB to LSB
      bt = (self.accum_buffer >> UInt[64](56)) & UInt[64](0xFF)
      # idk, jpeg does this
      if bt == UInt[64](0xFF) and stuff_zero_byte:
        self.output_buffer[self.output_sz] = byte(0)
        self.output_sz += 1
        self.flush_output_if()
      self.output_buffer[self.output_sz] = byte(bt)
      self.output_sz += 1      
      self.accum_buffer <<= UInt[64](8) # get rid of the byte we just did
      self.accum_sz -= 8
      self.flush_output_if()

  # see if we need to flush our output buffer to file
  def flush_output_if(self):
    if self.output_sz == 64:
      assert _C.fwrite(self.output_buffer, 1, 64, self.fd.fp) == 64
      self.output_sz = 0
      self.fd.flush()

  # force accum_buffer to be put to output_buffer, then flush output buffer
  def flush_all(self):
    # pack on 1s if we have partial bytes
    partial = self.accum_sz & 7
    nbits = 64 - partial
    val = (1 << nbits) - 1
    uval = UInt[64](val)
    uval &= UInt[64]((1 << nbits)-1)
    self.accum_sz += nbits
    uval <<= UInt[64](64-self.accum_sz)
    uval |= self.accum_buffer
    self.accum_buffer = uval
    self.put_if(0)    
    assert _C.fwrite(self.output_buffer, 1, self.output_sz, self.fd.fp) == self.output_sz
    self.output_sz = 0
    self.fd.flush()
      
@extend
class byte:

  def __new__(val) -> byte:
    return byte.process(val)

  def process[T: int](val: Int[T]) -> byte:
    if T == 8:
      return byte.process_eq(val)
    elif T < 8:
      return byte.process_ext(val)
    else:
      return byte.process_trunc(val)

  def process[T: int](val: UInt[T]) -> byte:
    if T == 8:
      return byte.process_eq(val)
    elif T < 8:
      return byte.process_ext(val)
    else:
      return byte.process_trunc(val)      
  @llvm
  def process_trunc[T: int](val: Int[T]) -> byte:
    %0 = trunc i{=T} %val to i8
    ret i8 %0
  @llvm
  def process_trunc[T: int](val: UInt[T]) -> byte:
    %0 = trunc i{=T} %val to i8
    ret i8 %0
  @llvm
  def process_ext[T: int](val: Int[T]) -> byte:
    %0 = zext i{=T} %val to i8
    ret i8 %0
  @llvm
  def process_ext[T: int](val: UInt[T]) -> byte:
    %0 = zext i{=T} %val to i8
    ret i8 %0
  @llvm
  def process_eq[T: int](val: Int[T]) -> byte:
    ret i8 %val
  @llvm
  def process_eq[T: int](val: UInt[T]) -> byte:
    ret i8 %val


#class Bytes:
#  bits: Ptr[byte]
#  put_buffer: int
#  put_bits: int # bits in put_buffer
#
#  def __init__(self):
#    self.put_buffer = 0
#    self.put_bits = 0
#
#  def pack(code: int, nbits: int):
#    cur_bits = self.put_bits
#    code &= (1<<nbits) - 1
#    cur_bits += nbits
#    code <<= 64 - cur_bits
#    cur_bits |= self.put_buffer
#    
#
## N = underlying buffer bytes
#class Bits[BY: int]:
#  bits: UInt[BY*8]
#  fd: File
#  sz: int # number of bits currently occupied
#  
#  def __init__(self, fd: File):
#    self.bits = UInt[BY*8](0)
#    self.fd = fd
#    self.sz = 0
#
#  def _put_if(self, force: bool = False):
#    if (self.sz == BY*8 or force) and self.sz > 0:
#      self.fd.write_u[BY,BY*8](self.bits)
#      self.sz = 0
#      self.bits = UInt[BY*8](0)
#
#  # dynamic bits
#  def pack[T: int](self, val: UInt[T], nbits: int):
#    assert nbits <= T
#    while nbits > 0:
#      print(nbits)
#      m = min(BY*8-self.sz, nbits)
#      # shift off the LSB bits that we don't need for this iteration
#      shift = UInt[T]((1 << (nbits - m + 1))-1)
#      tmp = val >> shift
#      # convert to UInt[B]
#      b = tmp.zext_or_trunc[BY*8]()
#      # shift to location in bits
#      b <<= UInt[BY*8]((BY*8-self.sz-m))
#      # add to bit seq
#      self.bits |= b
#      self.sz += m
#      nbits -= m
#      self._put_if()
#
#  def pack[T: int](self, val: Int[T], nbits: int):
#    self.pack[T](val.as_uint(), nbits)
#
#  def pack(self, val: int, nbits: int):
#    self.pack[64](val.as_uint(), nbits)
#
  # static bits
#  def pack[BI:int, T: int](self, val: UInt[T]):
#    nbits = BI
#    while nbits > 0:
#      print(nbits)
#      m = min(BY*8-self.sz, nbits)
#      print(m)
#      # shift off the LSB bits that we don't need for this iteration
#      shift = UInt[T]((1 << (nbits - m + 1))-1)
#      tmp = val >> shift
#      # convert to UInt[B]
#      b = tmp.zext_or_trunc[BY*8]()
#      # shift to location in bits
#      b <<= UInt[BY*8]((BY*8-self.sz-m))
#      # add to bit seq
#      self.bits |= b
#      self.sz += m
#      nbits -= m
#      print(nbits)
#      self._put_if()

#  def pack[BI:int, T:int](self, val: Int[T]):
#    self.pack[BI,T](val.as_uint())

#  def pack[BI:int](self, val: int):
#    self.pack[BI,64](val.as_uint())
    
  # dump any remaining bits to the stream
#  def flush(self):
#    self._put_if(True)  

@extend
class File:
  
  # T = bytes
  def read_u[T: int](self) -> UInt[T*8]:
    self._ensure_open()
    buf = Ptr[byte](T)
    assert _C.fread(buf, 1, T, self.fp) == T
    self._errcheck("error in read")
    return buf.convert_u[T*8]()

  def read_s[T: int](self) -> Int[T*8]:
    self._ensure_open()
    buf = Ptr[byte](T)
    assert _C.fread(buf, 1, T, self.fp) == T
    self._errcheck("error in read")
    return buf.convert_s[T*8]()

#  # BY = # bytes to write
#  # T is the input which we pull BY bytes out of
#  def write_u[BY: int, T: int](self, u: UInt[T]):
#    self._ensure_open()
#    assert _C.fwrite(u.to_ptr(), 1, BY, self.fp) == 1
#    self._errcheck("error in write")
#
#  # BY = # bytes to write
#  # BI is the input
#  def write_u[BY: int, T: int](self, u: Int[T]):
#    self._ensure_open()
#    assert _C.fwrite(u.to_ptr(), 1, BY, self.fp) == 1
#    self._errcheck("error in write")
#
#  def write_u[BY: int](self, u: int):
#    self._ensure_open()
#    assert _C.fwrite(u.to_ptr(), 1, BY, self.fp) == 1
#    self._errcheck("error in write")
#
#@extend
#class UInt[T]:
#  # like the __pickle__ operation
#  @llvm
#  def to_ptr(self) -> Ptr[byte]:
#    %0 = alloca i{=T}
#    store i{=T} %self, i{=T}* %0
#    %1 = bitcast i{=T}* %0 to i8*
#    ret i8* %1
#  @llvm
#  def uint_zext[F: int, Q: int](what) -> UInt[Q]:
#    %0 = zext i{=F} %what to i{=Q}
#    ret i{=Q} %0
#  @llvm
#  def uint_trunc[F: int, Q: int](what) -> UInt[Q]:
#    %0 = trunc i{=F} %what to i{=Q}
#    ret i{=Q} %0
#  def zext_or_trunc[Q: int](self) -> UInt[Q]:
#    if T < Q:
#      return UInt.uint_zext[T,Q](self)
#    elif T == Q:
#      return self
#    else: # T > Q
#      return UInt.uint_trunc[T,Q](self)
#
#@extend
#class Int[T]:
#  # for this, just return it and the bits are reinterpreted. I think
#  @llvm
#  def as_uint(self) -> UInt[T]:
#    ret i{=T} %self
#
#@extend
#class int:
#  # like the __pickle__ operation
#  @llvm
#  def to_ptr(self) -> Ptr[byte]:
#    %0 = alloca i64
#    store i64 %self, i64* %0
#    %1 = bitcast i64* %0 to i8*
#    ret i8* %1
#  # for this, just return it and the bits are reinterpreted. I think
#  @llvm
#  def as_uint(self) -> UInt[64]:
#    ret i64 %self
#
@extend
class Ptr[T]:
  @llvm
  def convert_u[N: int](self) -> UInt[N]:
    %0 = bitcast {=T}* %self to i{=N}*
    %1 = load i{=N}, i{=N}* %0 
    ret i{=N} %1  
  @llvm
  def convert_s[N: int](self) -> Int[N]:
    %0 = bitcast {=T}* %self to i{=N}*
    %1 = load i{=N}, i{=N}* %0 
    ret i{=N} %1    

@extend
class float:
  def __new__(i) -> float:
    return float._to_float(i)
  @llvm
  def _to_float[N:int](i: UInt[N]) -> float:
    %0 = uitofp i{=N} %i to double
    ret double %0
  @llvm
  def _to_float[N:int](i: Int[N]) -> float:
    %0 = sitofp i{=N} %i to double
    ret double %0

#
#
## everything bit and built-in-type related
#
## TODO I might be able to just do LLVM for some of these operations (but I can't use UInt[N]/Int[N] since I 
## don't have a static N). maybe just call this bits and have it represent raw bits then you can just convert
## it between whatever you want
#
#u1 = UInt[1]
#
## Note to self: I can't just use UInt[N] here because I don't statically know the size in every case
#
## basic idea: the individual values you append (or init with) have their MSB bits trimmed off to match the specified size
## then that value is shifted toward the MSB of the current bitseq. So, bits are always packed from MSB->LSB.
## bit_seqs[0] -> MSB 
## bit_seqs[-1] -> LSB
## Thus, bitwidths for appending measure from LSB to MSB, but effective width measures from MSB->LSB
## TODO I coudl parameterize this by the size of each bitseq that I want (If it allows me to do defaults, I can have BitSeq[N=64] or somehting)
#class BitSeq:
#
#  # inputs bits are taken as they are -- i.e. we ignore the endianess. 
#  # when you append other bits (i.e. pack), it is always packed towards the LSB side
#  # i.e
#  # first input: 0b01010
#  # now pack on 10
#  # becomes: 0b0101010
#  #                 ^^ packed on here
#  # now reshift to align on LSB
#  # final: 0b00101010
#
#  # for storage, everythign is aligned towards the LSB. But when you pack, we align to the MSB, pack after the MSB (towards
#  # the LSB), and then realign to the LSB
#  effective_width: int
#  bit_seqs: list[u64]
#  nseqs: int
#
#  # completely brain-dead and slow bit packing that just iterates through to pack one bit at a time
#  def _pack_bits(self, val: u64, width: int):
#    it = iter(val)
#    # skip the MSBs we don't need
#    for _ in range(64-width):      
#      next(it)
#    for i in range(width):
#      v = u64(next(it))
#      cur_bit_seq = u64(0)
#      if self.nseqs == 0 or self.effective_width & 63 == 0:
#        # need a new sequence
#        self.bit_seqs.append(cur_bit_seq)
#        self.nseqs += 1
#      else:
#        # MSB align the current bitseq (since it is always stored as LSB aligned)
#        align_shift = 64 - (self.effective_width & 63)
#        # sanity check
#        assert align_shift != 64 # should never reach this
#        cur_bit_seq = self.bit_seqs[-1] << u64(align_shift)
#      msb_bit_idx = self.effective_width & 63 # counted from the MSB->LSB
#      # move the single bit to the correct lcation
#      v <<= u64(63-msb_bit_idx) 
#      cur_bit_seq |= v
#      # LSB align again
#      self.effective_width += 1
#      rshift = 63-msb_bit_idx
#      self.bit_seqs[-1] = (cur_bit_seq >> u64(rshift))
#
#  # width here is measured from the LSB->MSB, which is different than the effective_width which measures
#  # from MSB->LSB. I do this because if you want to pass in decimal values (say 10, which is 0b1010, or maybe 0b000001010),
#  # you wouldn't want to take the MSB bits in this case.
#
#  def __init__(self):
#    self.effective_width = 0
#    self.bit_seqs = []
#    self.nseqs = 0
#
#  # width can be different than the actual type since you might not want all of the bits
#  def __init__(self, val: u1):
#    self.__init__()
#    self._pack_bits(u64(val), 1)
#
#  def __init__(self, val: u8, width: int=8):
#    self.__init__()
#    assert width >= 1 and width <= 8
#    self._pack_bits(u64(val), width)
#
#  def __init__(self, val: u16, width: int=16):
#    self.__init__()
#    assert width >= 1 and width <= 16
#    self._pack_bits(u64(val), width)
#
#  def __init__(self, val: u32, width: int=32):
#    self.__init__()
#    assert width >= 1 and width <= 32
#    self._pack_bits(u64(val), width)
#
#  def __init__(self, val: u64, width: int=64):
#    self.__init__()
#    assert width >= 1 and width <= 64
#    self._pack_bits(u64(val), width)
#
#  def __init__(self, val: int, width: int=64): 
#    self.__init__()
#    assert width >= 1 and width <= 64
#    self._pack_bits(u64(val), width)
#
#  def __init__(self, s: str, width: int):
#    self.__init__()
#    assert width >= 1 and width <= 64
#    assert 8 * len(s) >= width # need enough bits
#    sum = u64(0)   
#    # go through each bit. This is so we can handle odd numbers of bits
#    for idx in range(width):
#      cur_byte = idx // 8
#      # get the bit we are intersted in
#      bitidx = idx & 7
#      bit = u1(u8(s.ptr[cur_byte]) >> u8(bitidx))
#      bit &= u1(1)
#      shft = u64(cur_byte * 8 + (idx & 7))
#      shftbit = u64(bit) << shft
#      sum |= shftbit
#    self._pack_bits(sum, width)
#
#  def nbits(self) -> int:
#    return self.effective_width
#
#  def pack(self, val: BitSeq):
#    w = val.effective_width
#    for bitseq in val.bit_seqs[:-1]:
#      self._pack_bits(bitseq, 64)
#      w -= 64
#    # need to align the last one to the right hand side
#    last_seq = val.bit_seqs[-1]
#    self._pack_bits(last_seq, w)
#
#  def pack(self, val: u1):
#    self._pack_bits(u64(val), 1)
#
#  def pack(self, val: u8, width: int=8):
#    assert width >= 1 and width <= 8
#    self._pack_bits(u64(val), width)
#
#  def pack(self, val: u16, width: int=16):
#    assert width >= 1 and width <= 16
#    self._pack_bits(u64(val), width)
#
#  def pack(self, val: u32, width: int=32):
#    assert width >= 1 and width <= 32
#    self._pack_bits(u64(val), width)
#
#  def pack(self, val: u64, width: int=64):
#    assert width >= 1 and width <= 64
#    self._pack_bits(u64(val), width)
#
#  def pack(self, val: int, width: int=64): 
#    assert width >= 1 and width <= 64
#    self._pack_bits(u64(val), width)
#
#  def __iter__(self) -> Generator[UInt[1]]:
#    w = self.effective_width
#    for i in range(self.nseqs-1):      
#      for b in self.bit_seqs[i]:
#        yield UInt[1](b)
#        w -= 1
#    # get remaining bits
#    it = self.bit_seqs[-1].msb_iter_from(64-w)
#    for i in range(w):
#      yield next(it)
#    it.destroy()
#
#  # prints out in binary
#  def __str__(self) -> str:
#    s = ''
#    for b in self:
#      s += str(b)
#    return '0b' + s
#
#  def __eq__(self, other: BitSeq) -> bool:
#    if self.effective_width != other.effective_width:
#      return False
#    w = self.effective_width
#    for i in range(self.nseqs-1):
#      self_bs = self.bit_seqs[i]
#      other_bs = other.bit_seqs[i]
#      if self_bs != other_bs:
#        return False
#      w -= 64
#    # check remaining bits
#    self_bs = self.bit_seqs[self.nseqs-1]
#    other_bs = other.bit_seqs[self.nseqs-1]
#    if self_bs != other_bs:
#      return False
#    return True
#
#  def __eq__[N: int](self, other: UInt[N]):
#    bother = BitSeq(other, N)
#    return self == bother
#      
#  def __ne__(self, other):
#    return not (self == other)
#
#  def _iter_ones(self):
#    idx = 0 
#    w = self.effective_width
#    for i in range(self.nseqs-1):
#      bs = self.bit_seqs[i]
#      for b in range(64):
#        bit = (bs >> u64(64-b-1)) & u64(1)
#        if bit == u64(1):
#          yield idx
#        idx += 1
#        w -= 1
#    bs = self.bit_seqs[-1]
#    for b in range(w):
#      # remember, stored as LSB aligned
#      bit = u1((bs >> u64(w - b - 1)) & u64(1))
#      if bit == u1(1):
#        yield idx
#      idx += 1    
#
#  def __ge__(self, other: BitSeq):
#    # go through from MSB to LSB comparing the values
#    self_iter = self._iter_ones()
#    other_iter = other._iter_ones()
#    while True:
#      try:
#        sb = next(self_iter)
#        ob = next(other_iter)
#        if sb == ob:
#          continue
#        else:
#          self_iter.destroy()
#          other_iter.destroy()
#          # found a differing index
#          return sb <= ob # <= b/c it's from the MSB side
#      except StopIteration:
#        self_iter.destroy()
#        other_iter.destroy()
#        # no more ones, so they both had the same till this point
#        return True
#
#  def __gt__(self, other: BitSeq):
#    # go through from MSB to LSB comparing the values
#    self_iter = self._iter_ones()
#    other_iter = other._iter_ones()
#    while True:
#      try:
#        sb = next(self_iter)
#        ob = next(other_iter)
#        if sb == ob:
#          continue
#        else:
#          # found a differing index
#          self_iter.destroy()
#          other_iter.destroy()
#          return sb < ob
#      except StopIteration:
#        self_iter.destroy()
#        other_iter.destroy()
#        # no more ones, so they both had the same till this point
#        return False
#
#  def __le__(self, other: BitSeq):
#    return not (self > other)
#
#  def __lt__(self, other: BitSeq):
#    return not (self >= other)
#
#  def __int__(self) -> int:
#    if self.nseqs == 0:
#      return 0
#    else:
#      return int(self.bit_seqs[0])
#
## used in conjunction with int/uint[N].new to get stuff as raw unisnged chars
## get raw unsigned characters from a string
#@extend
#class byte:
#  def zext_or_trunc[T: int](self) -> UInt[T]:
#    if 8 < T:
#      return UInt.uint_zext[8,T](self)
#    elif 8 == T:
#      return UInt.ident[8](self)
#    else: # N > T
#      return UInt.uint_trunc[8,T](self)    
#
#@extend 
#class UInt[N]:
#
#  def __new__(val: BitSeq) -> UInt[N]:
#    ui = UInt[N]()
#    idx = 0
#    n = N-1
#    for b in val:
#      ui |= (UInt[N](b) << UInt[N](n))
#      n -= 1    
#    return ui    
#
#  def __new__(val) -> UInt[N]:
#    return val.zext_or_trunc[N]()
#  @llvm
#  def __new__(val: float) -> UInt[N]:
#    %0 = fptoui double %val to i{=N}
#    ret i{=N} %0
#  @llvm
#  def ident[T: int](what) -> UInt[T]:
#    ret i{=T} %what
#  @llvm
#  def uint_zext[F: int, T: int](what) -> UInt[T]:
#    %0 = zext i{=F} %what to i{=T}
#    ret i{=T} %0
#  @llvm
#  def uint_trunc[F: int, T: int](what) -> UInt[T]:
#    %0 = trunc i{=F} %what to i{=T}
#    ret i{=T} %0
#  @llvm
#  def to_float(self) -> float:
#    %0 = uitofp i{=N} %self to double
#    ret double %0
#  def zext_or_trunc[T: int](self) -> UInt[T]:
#    if N < T:
#      return UInt.uint_zext[N,T](self)
#    elif N == T:
#      return self
#    else: # N > T
#      return UInt.uint_trunc[N,T](self)
#
#  # this is MSB to LSB iter
#  def __iter__(self) -> Generator[u1]:
#    return self.msb_iter_from(0)
#
#  # starts at idx relative to msb
#  def msb_iter_from(self, idx):
#    for i in range(N-idx):
#      yield u1(self >> UInt[N]((N-idx-i-1)))
#
#  def __eq__(self, other: BitSeq):
#    return BitSeq(self, N) == other
#
#  def __neq__(self, other: BitSeq):
#    return BitSeq(self, N) != other
#
#  def __ge__(self, other: BitSeq):
#    return BitSeq(self, N) >= other
#
#  def __gt__(self, other: BitSeq):
#    return BitSeq(self, N) > other
#
#  def __le__(self, other: BitSeq):
#    return BitSeq(self, N) <= other
#
#  def __lt__(self, other: BitSeq):
#    return BitSeq(self, N) < other
#
#@extend
#class File:
#  def write(self, arr: Array[byte]):
#    self._ensure_open() 
#    _C.fwrite(arr.ptr, 1, len(arr), self.fp) 
#    self._ensure_open() 
#
#@extend
#class str:
#  def __sub__(self, other: str) -> u8:
#    return u8(BitSeq(self, 8)) - u8(BitSeq(other, 8))
#
#@extend 
#class float:
#  def __new__(val) -> float:
#    return val.to_float()
#
