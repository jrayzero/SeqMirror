from cola.cola_error import ColaError
import random,string
import math

@extend
class Array[T]:
  def __str__(self) -> str:
    return '[' + ','.join([str(self[i]) for i in range(self.len)]) + ']'

@extend
class Slice:
  def compute_range(self):
    return int(math.ceil((~self.stop - ~self.start) / ~self.step))

# TODO make dims and stuff like that be uints (and exslices stop be int sand allow ti to be negative)

class Multidim[T]:
  dims: list[int] # dims for just your little region
  buffer_mapping: list[Slice] # the mapping to your immediate parent
  # views contain a pointer to their referenced buffer
  buffer: Array[T]
#  buffer_parent.dims: list[int] # original dims of the buffer. use for linearization
  buffer_parent: Multidim[T]
  unique_id: str
  is_backing_buffer: bool  
  dim_offset: int # total front dimensions elided
#  back_dim_offset: int # total back dimensions elided

class View[T]:
  base: Multidim[T]

class Block[T]:
  base: Multidim[T]

@extend
class Multidim[T]:

  ### INIT FUNCTIONS

  def __init__(self):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    self.is_backing_buffer = False
    self.dim_offset = 0
    
  def __init__(self, other: Block[T], set_as_parent: bool):
    self.__init__()
    self.dims = [d for d in other.dims()]
    if set_as_parent:
      self.buffer_parent = other.base.buffer_parent
      self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
      self.buffer = other.base.buffer
    else:
      self.buffer_parent = self#other.base.buffer_parent
      self.buffer = Array[T](self.nunits())
      self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
      self.is_backing_buffer = True
    self.dim_offset = other.base.dim_offset

  def __init__(self, other: View[T], set_as_parent: bool):
    self.__init__()
    self.dims = [d for d in other.dims()]
    if set_as_parent:
      self.buffer_parent = other.base.buffer_parent
      self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
      self.buffer = other.base.buffer
    else:
      raise ColaError()
      self.buffer_parent = other.base.buffer_parent
      self.buffer = Array[T](self.nunits())
      self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
      self.is_backing_buffer = True
    self.dim_offset = other.base.dim_offset
#    self.back_dim_offset = other.base.back_dim_offset

  def __init__(self, other: int, _:bool):
    self.__init__()
    self.dims = [other]
    self.buffer = Array[T](other)
    self.buffer_parent = self
    self.is_backing_buffer = True
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]

  def __init__(self, dims: list[int], _:bool):
    self.__init__()
    self.dims = [d for d in dims]
    self.buffer = Array[T](self.nunits())
    self.buffer_parent = self
    self.is_backing_buffer = True
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]

  # 2D and above
  def __init__(self, dim0, dim1, *dims):
    self.__init__()
    self.dims = [dim0, dim1]
    if staticlen(dims) > 0:
      self.dims += [d for d in dims]
    self.buffer_parent = self
    self.buffer = Array[T](self.nunits())
    self.is_backing_buffer = True
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]

  # init dims and fill immediately (MAKES A SHALLOW COPY)
  def __init__(self, dims, data: Array[T]):
    self.__init__()
    self.dims = [d for d in dims]
    self.buffer = data
    self.buffer_parent = self
    self.is_backing_buffer = True
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]

  def __init__(self, dims, data: list[T]):
    self.__init__()
    self.dims = [d for d in dims]
    self.buffer = data.arr
    self.buffer_parent = self
    self.is_backing_buffer = True
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]

  def _linearize(self, coord: list[int]) -> int:
    if len(self.buffer_parent.dims) != len(coord):
      raise ColaError()
    linear = 0
    for idx,c in enumerate(reversed(coord)):
      s = c
      for i in range(idx):
        s *= self.buffer_parent.dims[len(coord) - i - 1]
      linear += s
    return linear

  ### INTERNAL NON-STATIC UTILITY FUNCTIONS

  def _broadcast_binary_arithmetic[S=T](self, other: T, op_func_ptr) -> Multidim[S]:
    for l in self._iterate():
      self.buffer[l] = op_func_ptr(self.buffer[l], other)

  def _elementwise_binary_arithmetic[S=T](self, other: Multidim[T], op_func_ptr) -> Multidim[S]:
    for l1,l2 in zip(self._iterate(), other._iterate()):
      self.buffer[l1] = op_func_ptr(self.buffer[l1], other.buffer[l2])

  ### PUBLIC UTILITY FUNCTIONS

  def nunits(self):
    n = 1
    for d in self.dims:
      n *= d
    return n

  # gets origin relative to direct ancestors block
  # TODO have another function that can specify which thing to be relative to
  def origin(self) -> list[int]:
    return [~p.start for p in self.buffer_mapping]

  # call these from Block/View.reshape
  # reshaping doesn't create a parent mapping

  # can elide size one dimensions
  def elide_front(self, amt: int = 1) -> Multidim[T]:    
    for i in range(amt):
      if i >= len(self.dims):
        raise ColaError("eliding too much")
      if self.dims[i] != 1:
        raise ColaError("non-unit dimension")
    md = Multidim[T]()
    md.dims = [d for d in self.dims[amt:]]
    md.dim_offset = self.dim_offset + amt
#    md.back_dim_offset = self.back_dim_offset
    md.buffer_parent = self.buffer_parent
    md.buffer = self.buffer
    md.buffer_mapping = self.buffer_mapping    
    return md

  def elide_back(self, amt: int = 1) -> Multidim[T]:
    for i in range(amt):
      if i >= len(self.dims):
        raise ColaError("eliding too much")
      if self.dims[len(self.dims) - i - 1] != 1:
        raise ColaError("non-unit dimension")
    md = Multidim[T]()
    md.dims = [d for d in self.dims[:len(self.dims) - amt]]
    md.dim_offset = self.dim_offset
 #   md.back_dim_offset = self.back_dim_offset + amt
    md.buffer_parent = self.buffer_parent
    md.buffer = self.buffer
    md.buffer_mapping = self.buffer_mapping
    return md
    
  def _convert(self, idx: int, i: int):
    return 1,Slice(idx,idx+1,1)
    
  def _convert(self, idx: Slice, it: int):
    idx2 = idx.adjust_indices(self.dims[it])
    idx = Slice(idx2[0], idx2[1], idx2[2])
    # compute effective end
    end = idx.compute_range()
    return end,idx  
  
  def __getitem__(self, idx: int) -> Multidim[T]:
    if len(self.dims) != 1:
      raise ColaError("Must be 1D Multidim")
    if idx >= self.dims[0]:
      raise ColaError("Invalid index")
    if idx < 0:
      idx = idx + self.dims[0]
    if idx < 0:
      raise ColaError("Bad idx")

    # update the mapping, which contains all dimensions
    mapping = [sl for sl in self.buffer_mapping]
    orig = mapping[self.dim_offset]
    mapping[self.dim_offset] = Slice(~orig.start + idx, ~orig.start + idx+1,1)
    # update dims
    dims = [1]

    md = Multidim[T]()
    md.dim_offset = self.dim_offset
  #  md.back_dim_offset = self.back_dim_offset
  #    md.buffer_parent.dims = self.buffer_parent.dims
    md.buffer = self.buffer
    md.buffer_parent = self.buffer_parent
    md.dims = dims
    md.buffer_mapping = mapping
    return md
  
  def __getitem__(self, idx: Slice) -> Multidim[T]:
    return self[[idx]]

  # should be a tuple of things
  def __getitem__(self, idxs) -> Multidim[T]:    
    if len(idxs) != len(self.dims):
      raise ColaError()
    # get current mappings
    mapping = [sl for sl in self.buffer_mapping]
    dims = [d for d in self.dims]
    # and now update
    i = 0
    for idx in idxs:
      d,sl = self._convert(idx, i)
      dims[i] = d
      repl = mapping[i + self.dim_offset]
      # sl is relative to self, repl is relative to buffer
      start = ~repl.start + ~sl.start * ~repl.step
      stop = min(~repl.start + ~sl.stop * ~repl.step, ~repl.stop)
      step = ~repl.step * ~sl.step
      mapping[i + self.dim_offset] = slice(start, stop, step) 
      i += 1
      
    md = Multidim[T]()
    md.dim_offset = self.dim_offset
#    md.back_dim_offset = self.back_dim_offset
    md.buffer = self.buffer
 #   md.buffer_parent.dims = self.buffer_parent.dims
    md.buffer_parent = self.buffer_parent
    md.dims = dims
    md.buffer_mapping = mapping
    return md

  ### __CALL__ AND ASSOCIATED FUNCTIONS
  
  # all the calls realized a SINGLE element
  def __call__(self) -> T:
    if self.nunits() != 1:
      raise ColaError()
    coord = [~sl.start for sl in self.buffer_mapping]
    return self.buffer[self._linearize(coord)]

  def __call__(self, idxs) -> T:
    return self[idxs]()

  def __call__(self, idx0, idx1, *idx) -> T:
    tup = (idx0, idx1) + tuple(iter(i) for i in idx)
    return self.__getitem__(tup)()

  ### __SETITEM__ AND ASSOCIATED FUNCTIONS

  def _iterate(self):
    # default iterators are from the buffer mapping since we may have some back elided dimensions
    return self._iterate([~d.start for d in self.buffer_mapping], 0)

  def iterate(self):
    # default iterators are from the buffer mapping since we may have some back elided dimensions
    return self._iterate([~d.start for d in self.buffer_mapping], 0)

  def _iterate(self, iterators: list[int], cur_depth: int):
    if cur_depth == len(self.dims) - 1:#(1 + self.dim_offset + self.back_dim_offset):
      cmap = self.buffer_mapping[cur_depth+self.dim_offset]
      for i in range(~cmap.start, ~cmap.stop, ~cmap.step):
        iterators[cur_depth+self.dim_offset] = i
        linear = self._linearize(iterators)
        yield linear
    else:
      cmap = self.buffer_mapping[cur_depth+self.dim_offset]
      for i in range(~cmap.start, ~cmap.stop, ~cmap.step):
        iterators[cur_depth+self.dim_offset] = i
        yield from self._iterate(iterators, cur_depth+1)

  def slice_iterate(self):
    return self._slice_iterate([~d.start for d in self.buffer_mapping], 0)

  def _slice_iterate(self, iterators: list[int], cur_depth: int):
    if cur_depth == len(self.dims) - 1:#(1 + self.dim_offset + self.back_dim_offset):
      cmap = self.buffer_mapping[cur_depth+self.dim_offset]
      for i in range(~cmap.start, ~cmap.stop, ~cmap.step):
        iterators[cur_depth+self.dim_offset] = i
        elide_amt = len(self.buffer_parent.dims) - 1
        yield self.buffer_parent[iterators].elide_back(elide_amt)
    else:
      cmap = self.buffer_mapping[cur_depth+self.dim_offset]
      for i in range(~cmap.start, ~cmap.stop, ~cmap.step):
        iterators[cur_depth+self.dim_offset] = i
        yield from self._slice_iterate(iterators, cur_depth+1)

  def __iter__(self) -> Generator[Multidim[T]]:
    return self.slice_iterate()

  # The setitems work by slicing into self with the idxs, and then performing the write
  def __setitem__(self, idx: int, item: T):
    sliced = self[idx]
    sliced._write(item)
#    coord = [~sl.start for sl in sliced.buffer_mapping]
#    print(coord)
#    sliced.buffer[sliced._linearize(coord)] = item

  def __setitem__(self, idxs, item):
    sliced = self[idxs]
    sliced._write(item)

  def _write(self, item: T):
    # broadcast it
    for l in self._iterate():
      self.buffer[l] = item

  def _write(self, items: list[T]):
    assert len(items) == self.nunits()
    idx = 0
    for l in self._iterate():
      self.buffer[l] = items[idx]
      idx += 1

  def _write(self, item: Multidim[T]):
    assert self.nunits() == item.nunits()
    for l1,l2 in zip(self._iterate(), item._iterate()):
      self.buffer[l1] = item.buffer[l2]

  def _write(self, item: Block[T]):
    self._write(item.base) 

  def _write(self, item: View[T]):
    self._write(item.base)

  # iterate through the whole buffer mapping, but make it seem
  # like it is an elided region
  def _str_iterate(self, iterators: list[int], cur_depth: int):
    if cur_depth == len(self.dims) - 1:#(1 + self.dim_offset + self.back_dim_offset):
      cmap = self.buffer_mapping[cur_depth+self.dim_offset]
      s = ''
      if cur_depth == 0:
        s += '\n'
      for i in range(~cmap.start, ~cmap.stop, ~cmap.step):
        iterators[cur_depth+self.dim_offset] = i
        linear = self._linearize(iterators)
        s += ' ' + str(self.buffer[linear])
      return s
    else:
      cmap = self.buffer_mapping[cur_depth+self.dim_offset]
      s = ''
      for i in range(~cmap.start, ~cmap.stop, ~cmap.step):
        iterators[cur_depth+self.dim_offset] = i
        if cur_depth == 0 and len(self.dims) > 2:#(len(self.dims) - (self.dim_offset + self.back_dim_offset)) > 2:
          s += '\ndims idxs: ' + str(iterators[cur_depth+self.dim_offset])
        elif cur_depth < (len(self.dims) - 2):#(self.dim_offset + self.back_dim_offset)) - 2:
          s += ',' + str(iterators[cur_depth+self.dim_offset])
        else:
          s += '\n'
        s += self._str_iterate(iterators, cur_depth+1)
      return s
    
  def __str__(self):
    return self._str_iterate([~d.start for d in self.buffer_mapping], 0)

  def buffer_equals(self, other: Multidim[T]):
    if self.nunits() != other.nunits():
      return False
    for l1,l2 in zip(self._iterate(), other._iterate()):
      if self.buffer[l1] != other.buffer[l2]:
        return False
    return True

  def buffer_equals(self, other: list[T]):
    if self.nunits() != len(other):
      return False
    for l1,l2 in zip(self._iterate(), other):
      if self.buffer[l1] != l2:
        return False
    return True

  ### ARITHMETIC
    
  # broadcast
  def __add__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__add__)

  def __radd__(self, other: T) -> Multidim[T]:
    return self + other

  def __sub__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__sub__)

  def __rsub__(self, other: T) -> Multidim[T]:
    return self - other

  def __mul__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__mul__)

  def __rmul__(self, other: T) -> Multidim[T]:
    return self * other

  def __truediv__(self, other: T) -> Multidim[float]:
    return self._broadcast_binary_arithmetic[float](other, T.__truediv__)

  def __rtruediv__(self, other: T) -> Multidim[float]:
    return self / other

  def __floordiv__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__floordiv__)

  def __rfloordiv__(self, other: T) -> Multidim[T]:
    return self // other

  def __rshift__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__rshift__)

  def __rrshift__(self, other: T) -> Multidim[T]:
    return self >> other

  def __lshift__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__lshift__)

  def __rlshift__(self, other: T) -> Multidim[T]:
    return self << other

  def __lt__(self, other: T) -> Multidim[bool]:
    return self._broadcast_binary_arithmetic[bool](other, T.__lt__)

  def __le__(self, other: T) -> Multidim[bool]:
    return self._broadcast_binary_arithmetic[bool](other, T.__le__)

  def __gt__(self, other: T) -> Multidim[bool]:
    return self._broadcast_binary_arithmetic[bool](other, T.__gt__)

  def __ge__(self, other: T) -> Multidim[bool]:
    return self._broadcast_binary_arithmetic[bool](other, T.__ge__)

  def __eq__(self, other: T) -> Multidim[bool]:
    return self._broadcast_binary_arithmetic[bool](other, T.__eq__)

  def __ne__(self, other: T) -> Multidim[bool]:
    return self._broadcast_binary_arithmetic[bool](other, T.__ne__)

  # elementwise
  def __add__(self, other: Block[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__add__)

  def __add__(self, other: View[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__add__)

  def __sub__(self, other: Block[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__add__)

  def __sub__(self, other: View[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__add__)

  def __mul__(self, other: Block[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__add__)

  def __mul__(self, other: View[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__add__)

  def __truediv__(self, other: Block[T]) -> Multidim[float]:
    return self._elementwise_binary_arithmetic[float](other.base, T.__truediv__)

  def __truediv__(self, other: View[T]) -> Multidim[float]:
    return self._elementwise_binary_arithmetic[float](other.base, T.__truediv__)

  def __floordiv__(self, other: Block[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__floordiv__)

  def __floordiv__(self, other: View[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__floordiv__)

  def __rshift__(self, other: Block[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__rshift__)

  def __rshift__(self, other: View[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__rshift__)

  def __lshift__(self, other: Block[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__lshift__)

  def __lshift__(self, other: View[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other.base, T.__lshift__)

  def __lt__(self, other: Block[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__lt__)

  def __lt__(self, other: View[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__lt__)

  def __le__(self, other: Block[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__le__)

  def __le__(self, other: View[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__le__)

  def __gt__(self, other: Block[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__gt__)

  def __gt__(self, other: View[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__gt__)

  def __ge__(self, other: Block[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__ge__)

  def __ge__(self, other: View[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__ge__)

  def __eq__(self, other: Block[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__eq__)

  def __eq__(self, other: View[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__eq__)

  def __ne__(self, other: Block[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__ne__)

  def __ne__(self, other: View[T]) -> Multidim[bool]:
    return self._elementwise_binary_arithmetic[bool](other.base, T.__ne__)

# TODO appropriate base data type for buffer (is it a list)?
@extend
class Block[T]:

  # need separate init for block and view so it typechecks
  def __init__(self, other: Block[T]):
    self.base = Multidim[T](other, False)

  def __init__(self, other: View[T]):
    self.base = Multidim[T](other, False)

  def __init__(self, other):
    self.base = Multidim[T](other, False)

  def __init__(self, dims, data: list[T]):
    self.base = Multidim[T](dims, data)

  def __init__(self, dim0, dim1, *dims):
    self.base = Multidim[T](dim0, dim1, *dims)    

#  def elide_front(self, amt: int = 1):
#    return View[T](self.base.elide_front(amt))

#  def elide_back(self, amt: int = 1):
#    return View[T](self.base.elide_back(amt))

  def dims(self) -> list[int]:
    return self.base.dims

  def dims(self, idx: int) -> int:
    return self.base.dims[idx]

  def nunits(self):
    return self.base.nunits()

  # with __setitem__ and __getitem__, we don't need the star arg syntax because args automatically get grouped
  # as a tuple (or just a single item if is a 1D access)
  def __getitem__(self, idxs) -> View[T]:
    return View[T](self.base[idxs])
  
  def __setitem__(self, idxs, items):
    self.base[idxs] = items

  # gets a realized (concrete) value
  def __call__(self) -> T:
    return self.base()

  def __call__(self, idx: int) -> T:
    return self.base(idx)

  def __call__(self, idxs) -> T:
    return self.base(idxs)

  def __call__(self, idx0, idx1, *idxs) -> T:
    return self.base(idx0, idx1, *idxs)

  def __str__(self):
    return 'block\n' + str(self.base)

  def __add__(self, other):
    return Block(self.base + other)

  def __radd__(self, other):
    return Block(self.base.__radd__(other))

  def __sub__(self, other):
    return Block(self.base - other)

  def __rsub__(self, other):
    return Block(self.base.__rsub__(other))

  def __mul__(self, other):
    return Block(self.base * other)

  def __rmul__(self, other):
    return Block(self.base.__rmul__(other))

  def __truediv__(self, other):
    return Block[float](self.base / other)

  def __rtruediv__(self, other):
    return Block[float](self.base.__rtruediv__(other))

  def __floordiv__(self, other):
    return Block(self.base // other)

  def __rfloordiv__(self, other):
    return Block(self.base.__rfloordiv__(other))

  def __rshift__(self, other):
    return Block(self.base >> other)

  def __rrshift__(self, other):
    return Block(self.base.__rrshift__(other))

  def __lshift__(self, other):
    return Block(self.base << other)

  def __rlshift__(self, other):
    return Block(self.base.__rlshift__(other))

  def __lt__(self, other):
    return Block[bool](self.base < other)

  def __le__(self, other):
    return Block[bool](self.base <= other)

  def __gt__(self, other):
    return Block[bool](self.base > other)

  def __ge__(self, other):
    return Block[bool](self.base >= other)

  def __eq__(self, other):
    return Block[bool](self.base == other)

  def __ne__(self, other):
    return Block[bool](self.base != other)

  # iteration, which is just a row-major scan by default
  # yields single view values
  def __iter__(self) -> Generator[View[T]]:
    for item in self.base:
      yield View(item)

  def __bool__(self):
    return bool(self.base)

@extend
class View[T]:

  def __init__(self):
    self.base = Multidim[T]()

  # need separate init for block and view so it typechecks
  def __init__(self, parent: Block[T]):
    self.base = Multidim[T](parent, True)

  def __init__(self, parent: View[T]):
    self.base = Multidim[T](parent, True)

  def __init__(self, parent):
    self.base = Multidim[T](parent, True)

  def __init__(self, base: Multidim[T]):
    self.base = base

  def elide_front(self, amt: int = 1):
    return View[T](self.base.elide_front(amt))

  def elide_back(self, amt: int = 1):
    return View[T](self.base.elide_back(amt))

  def dims(self) -> list[int]:
    return self.base.dims

  def dims(self, idx: int) -> int:
    return self.base.dims[idx]

  def nunits(self):
    return self.base.nunits()

  # with __setitem__ and __getitem__, we don't need the star arg syntax because args automatically get grouped
  # as a tuple (or just a single item if is a 1D access)
  def __getitem__(self, idxs) -> View[T]:
    return View[T](self.base[idxs])
  
  def __setitem__(self, idxs, items):
    self.base[idxs] = items

  def __str__(self):
    return 'view\n' + str(self.base)

  # gets a realized (concrete) value
  def __call__(self) -> T:
    return self.base()

  def __call__(self, idx: int) -> T:
    return self.base(idx)

  def __call__(self, idxs) -> T:
    return self.base(idxs)

  def __call__(self, idx0, idx1, *idxs) -> T:
    return self.base(idx0, idx1, *idxs)

  def __add__(self, other):
    return Block(self.base + other)

  def __radd__(self, other):
    return Block(self.base.__radd__(other))

  def __sub__(self, other):
    return Block(self.base - other)

  def __rsub__(self, other):
    return Block(self.base.__rsub__(other))

  def __mul__(self, other):
    return Block(self.base * other)

  def __rmul__(self, other):
    return Block(self.base.__rmul__(other))

  def __truediv__(self, other):
    return Block[float](self.base / other)

  def __rtruediv__(self, other):
    return Block[float](self.base.__rtruediv__(other))

  def __floordiv__(self, other):
    return Block(self.base // other)

  def __rfloordiv__(self, other):
    return Block(self.base.__rfloordiv__(other))

  def __rshift__(self, other):
    return Block(self.base >> other)

  def __rrshift__(self, other):
    return Block(self.base.__rrshift__(other))

  def __lshift__(self, other):
    return Block(self.base << other)

  def __rlshift__(self, other):
    return Block(self.base.__rlshift__(other))

  def __lt__(self, other):
    return Block[bool](self.base < other)

  def __le__(self, other):
    return Block[bool](self.base <= other)

  def __gt__(self, other):
    return Block[bool](self.base > other)

  def __ge__(self, other):
    return Block[bool](self.base >= other)

  def __eq__(self, other):
    return Block[bool](self.base == other)

  def __ne__(self, other):
    return Block[bool](self.base != other)

  # iteration, which is just a row-major scan by default
  # yields single view values
  def __iter__(self) -> Generator[View[T]]:
    for item in self.base:
      yield View(item)

  def __bool__(self):
    return bool(self.base)

@extend
class File:
  # nelems is total number of elems to read and elem_bytes is the size of each elem
  def read[T](self, nelems: int, elem_bytes: int, block: Block[T]) -> int:
    self._ensure_open();
    assert len(block.base.buffer) >= nelems # make sure enough space
    ret = _C.fread(block.base.buffer.arr.ptr.as_byte(), T.len() // 8, nelems, self.fp)
    self._errcheck("error in read")
    return ret
