from cola.cola_error import ColaError
import random,string
import math

@extend
class Array[T]:
  def __str__(self) -> str:
    return '[' + ','.join([str(self[i]) for i in range(self.len)]) + ']'

@extend
class Slice:
  def compute_range(self):
    return int(math.ceil((~self.stop - ~self.start) / ~self.step))

  def cola_adjust(self, dlen):
    start = ~self.start if self.start else 0
    stop = ~self.stop if self.stop else dlen
    step = ~self.step if self.step else 1
    return Slice(start, stop, step)

# TODO make dims and stuff like that be uints (and exslices stop be int sand allow ti to be negative)

class CoordGrid:

  dims: list[int]
  unique_id: str
  
  def __init__(self, dims: list[int]):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    self.dims = [d for d in dims]

  def __init__(self, *dims):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    self.dims = [d for d in dims]

  def __eq__(self, other: CoordGrid):
    return self.unique_id == other.unique_id  

  def __ne__(self, other: CoordGrid):
    return not self == other

  def ndims(self):
    return len(self.dims)

# used for doing blk[ALL] = ... with a 1x1...x1 dim block.
# it's like blk(), but I can't have empty square brackets
# TODO change ALL to UNIT
class _ALL:
  def __init__(self):
    pass
ALL = _ALL()

# You always maintain a direct pointer to your closest Block parent
# If you want to go further up, need to do some extra computation
@dataclass(init=False)
class Multidim[T]:
  dims: list[int]
  buffer: Array[T]
  # the mapping to your buffer 
  buffer_mapping: list[Slice]
  # your parent with the buffer
  buffer_parent: Multidim[T]
  # your backing coordinate system
  cgrid: CoordGrid
  # your mapping to the coordinate system
  coord_mapping: list[Slice]  
  unique_id: str
  # you can fix dimensions of size 1
  nfixed_front: int
  nfixed_back: int

@dataclass(init=False)
class View[T]:
  base: Multidim[T]

@dataclass(init=False)
class Block[T]:
  base: Multidim[T]

@extend
class Multidim[T]:

  def __init__(self, other: Multidim[T]):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    if len(other.coord_mapping) == 0:
      raise ColaError()
    self.dims = [d for d in other.dims]
    self.buffer = other.buffer
    self.buffer_mapping = [s for s in other.buffer_mapping] #Slice(0,d,1) for d in self.dims]
    self.buffer_parent = other.buffer_parent
    self.cgrid = other.cgrid
    self.coord_mapping = [cm for cm in other.coord_mapping]
    self.nfixed_front = 0
    self.nfixed_back = 0
    
  def __init__(self, other: Block[T], make_buffer: bool):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    if len(other.base.coord_mapping) == 0:
      raise ColaError()
    self.dims = [d for d in other.dims()]
    if make_buffer: 
      self.buffer = Array[T](self.nunits())      
      self.buffer_parent = self
      self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
    else:
      self.buffer = other.base.buffer
      self.buffer_parent = other.base.buffer_parent
      self.buffer_mapping = [s for s in other.base.buffer_mapping]
    self.cgrid = other.base.cgrid
    self.coord_mapping = [cm for cm in other.base.coord_mapping]
    self.nfixed_front = 0
    self.nfixed_back = 0

  def __init__(self, other: Multidim[T], make_buffer: bool):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    if len(other.coord_mapping) == 0:
      raise ColaError()
    self.dims = [d for d in other.dims]
    if make_buffer: 
      self.buffer = Array[T](self.nunits())      
      self.buffer_parent = self
      self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
    else:
      self.buffer = other.buffer
      self.buffer_parent = other.buffer_parent
      self.buffer_mapping = [s for s in other.buffer_mapping]
    self.cgrid = other.cgrid
    self.coord_mapping = [cm for cm in other.coord_mapping]
    self.nfixed_front = 0
    self.nfixed_back = 0

  def __init__(self, other: View[T], make_buffer: bool):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    if len(other.base.coord_mapping) == 0:
      raise ColaError()
    self.dims = [d for d in other.dims()]
    if make_buffer: 
      self.buffer = Array[T](self.nunits())
      self.buffer_parent = self
      self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
    else:
      self.buffer = other.base.buffer
      self.buffer_parent = other.base.buffer_parent
      self.buffer_mapping = [s for s in other.base.buffer_mapping]
    self.cgrid = other.base.cgrid
    self.coord_mapping = [cm for cm in other.base.coord_mapping]
    self.nfixed_front = 0
    self.nfixed_back = 0

  def __init__(self, other: int, cgrid: CoordGrid):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    self.dims = [other]
    self.buffer = Array[T](other)
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
    self.buffer_parent = self 
    self.cgrid = cgrid
    self.coord_mapping = [Slice(0,d,1) for d in self.dims]
    if cgrid.ndims() != 1:
      raise ColaError()
    self.nfixed_front = 0
    self.nfixed_back = 0

  def __init__(self, dims: list[int], cgrid: CoordGrid):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    self.dims = [d for d in dims]
    self.buffer = Array[T](self.nunits())
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
    self.buffer_parent = self
    self.cgrid = cgrid
    self.coord_mapping = [Slice(0,d,1) for d in self.dims]
    if cgrid.ndims() != self.ndims():
      raise ColaError()
    self.nfixed_front = 0
    self.nfixed_back = 0

  def __init__(self, dims: list[int]):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    self.dims = [d for d in dims]
    self.buffer = Array[T](self.nunits())
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
    self.buffer_parent = self
    self.cgrid = CoordGrid(self.dims)
    self.coord_mapping = [Slice(0,d,1) for d in self.dims]
    self.nfixed_front = 0
    self.nfixed_back = 0

  # 2D and above
  def __init__(self, cgrid: CoordGrid, dim0: int, dim1: int, *dims):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    self.dims = [dim0, dim1]
    if staticlen(dims) > 0:
      self.dims += [d for d in dims]
    self.buffer = Array[T](self.nunits())
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
    self.buffer_parent = self
    self.cgrid = cgrid
    self.coord_mapping = [Slice(0,d,1) for d in self.dims]
    if cgrid.ndims() != self.ndims():
      raise ColaError()
    self.nfixed_front = 0
    self.nfixed_back = 0

  def __init__(self, dim0: int, dim1: int, *dims):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    self.dims = [dim0, dim1]
    if staticlen(dims) > 0:
      self.dims += [d for d in dims]
    self.buffer = Array[T](self.nunits())
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
    self.buffer_parent = self
    self.cgrid = CoordGrid(self.dims)
    self.coord_mapping = [Slice(0,d,1) for d in self.dims]
    if self.cgrid.ndims() != self.ndims():
      raise ColaError()
    self.nfixed_front = 0
    self.nfixed_back = 0

  # init dims and fill immediately (MAKES A SHALLOW COPY)
#  def __init__(self, dims, data: Array[T], cgrid: CoordGrid):
#    self.__init__()
#    self.dims = [d for d in dims]
#    self.buffer = data
#    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
#    self.buffer_parent = self
#    self.cgrid = cgrid
#    self.coord_mapping = [Slice(0,d,1) for d in self.dims]
#    if cgrid.ndims() != self.ndims():
#      raise ColaError()

  def __init__(self, dims, data: Array[T], cgrid: CoordGrid):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
#    self.__init__()
    self.dims = [d for d in dims]
    self.buffer = data
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
    self.buffer_parent = self
    self.cgrid = cgrid
    self.coord_mapping = [Slice(0,d,1) for d in self.dims]
    if cgrid.ndims() != self.ndims():
      raise ColaError()
    self.nfixed_front = 0
    self.nfixed_back = 0

  def __init__(self, dims, data: Array[T]):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
#    self.__init__()
    self.dims = [d for d in dims]
    self.buffer = data
    self.buffer_mapping = [Slice(0,d,1) for d in self.dims]
    self.buffer_parent = self
    self.cgrid = CoordGrid(self.dims)
    self.coord_mapping = [Slice(0,d,1) for d in self.dims]
    self.nfixed_front = 0
    self.nfixed_back = 0

  # for some internal creation
  def __init__(self, buffer: Array[T], dims: list[int], buffer_mapping: list[Slice], coord_mapping: list[Slice], buffer_parent: Multidim[T], cgrid: CoordGrid):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    self.dims = [d for d in dims]
    self.buffer = buffer
    self.buffer_mapping = [s for s in buffer_mapping]
    self.coord_mapping = [c for c in coord_mapping]
    self.buffer_parent = buffer_parent
    self.cgrid = cgrid
    self.nfixed_front = 0
    self.nfixed_back = 0

  def linearize(dims: list[int], coord: list[int]) -> int:
    if len(dims) != len(coord):
      raise ColaError()
    linear = 0
    for idx,c in enumerate(reversed(coord)):
      s = c
      for i in range(idx):
        s *= dims[len(coord) - i - 1]
      linear += s
    return linear

  def ndims(self):
    return len(self.dims)

  def fix_front(self, amt:int):
    cur_fixed = self.nfixed_front + self.nfixed_back
    if cur_fixed + amt >= len(self.dims):
      raise ColaError("Too many fixed dims")    
    copy = Multidim(self)
    copy.nfixed_front = self.nfixed_front + amt
    copy.nfixed_back = self.nfixed_back
    return copy

  def fix_back(self, amt:int):
    cur_fixed = self.nfixed_front + self.nfixed_back
    if cur_fixed + amt >= len(self.dims):
      raise ColaError("Too many fixed dims")
    copy = Multidim(self)
    copy.nfixed_front = self.nfixed_front
    copy.nfixed_back = self.nfixed_back + amt
    return copy
  
  def nunits(self):
    n = 1
    for d in self.dims:
      n *= d
    return n

  # gets your origin relative to your closest ancestor block or ZEROS if you
  # are a Block
  def origin(self) -> list[int]:    
    return [~p.start for p in self.buffer_mapping]

  def origin_relative_to(self, tree_relative) -> list[int]:    
    if self.cgrid != tree_relative.base.cgrid:
      raise ColaError("different ancestors")
    r_origin = [(~s.start-~s2.start) for s,s2 in zip(self.coord_mapping,tree_relative.base.coord_mapping)]
    return r_origin

  def origin_within(self, tree_relative) -> list[int]:    
    if self.cgrid != tree_relative.base.cgrid:
      raise ColaError("different ancestors")
    # TODO check that self is valid within tree_relative, meaning has a multiple location of tree_relative's stride
    # (other wise it doesn't make sense b/c you wouldn't be WITHIN tree_relative. it would just be relative to)
    for s,s2 in zip(self.coord_mapping,tree_relative.base.coord_mapping):
      assert (~s.start-~s2.start)%~s2.step == 0
    r_origin = [(~s.start-~s2.start)//~s2.step for s,s2 in zip(self.coord_mapping,tree_relative.base.coord_mapping)]
    return r_origin
    
  def _convert(self, idx: int, i: int):
    return 1,Slice(idx,idx+1,1)
    
  def _convert(self, idx: Slice, it: int):
    idx2 = idx.cola_adjust(self.dims[it])
    idx = Slice(idx2[0], idx2[1], idx2[2])
    # compute effective end
    end = idx.compute_range()
    return end,idx  
  
  def __getitem__(self, idx: _ALL) -> Multidim[T]:
    if self.nunits() != 1:
      raise ColaError()
    coord = [0] * len(self.dims)
    return self.__getitem__(coord)

  def __getitem__(self, idx: int) -> Multidim[T]:
    if len(self.dims) == 1:
      if idx >= self.dims[0]:
        raise ColaError("Invalid index")
      orig = self.buffer_mapping[0]
      md_buffer_mapping = [Slice(~orig.start+idx, ~orig.start+idx+1, 1)]
      orig = self.coord_mapping[0]
      md_coord_mapping = [Slice(~orig.start+idx, ~orig.start+idx+1, 1)]
      md = Multidim[T](self.buffer, [1], md_buffer_mapping, md_coord_mapping, self.buffer_parent, self.cgrid)
      # verify that the buffer mapping doesn't go negative (which can happen with neg idx)
      for b in md.buffer_mapping:
        if ~b.start < 0:
          raise ColaError("Bad idx")
      return md
    else:
      # defer to main getitem
      return self.__getitem__([idx])
  
  def __getitem__(self, idx: Slice) -> Multidim[T]:
    return self[[idx]]

  # get region in self that covers idx
  def __getitem__(self, idx: Multidim[T]):
    if self.cgrid != idx.cgrid:
      raise ColaError("different ancestors")
    for i in idx.coord_mapping:
      if ~i.step != 1:
        raise ColaError("don't know what to do here")
    for i in self.coord_mapping:
      if ~i.step != 1:
        raise ColaError("don't know what to do here")
    # get offset between self and idx
    rel_origin = [~s2.start-~s.start for s,s2 in zip(self.coord_mapping,idx.coord_mapping)]
    new_slices = [Slice(r, r + s.compute_range(), 1) for r,s in zip(rel_origin,idx.coord_mapping)]
    return self[new_slices]    
  
  # MUST INDEX WITH EITHER ALL DIMS OR LESS FRONT AND BACK FIXED
  # TODO need to check for out-of-bounds index here
  def __getitem__(self, idxs) -> Multidim[T]:    
    use_fixed = False # if false, either have no fixed dims, or you indexed with all dims
    if len(idxs) != len(self.dims):      
      if len(idxs) + self.nfixed_front + self.nfixed_back != len(self.dims):
        raise ColaError("bad number of dims to access")
      use_fixed = True
    dims = [d for d in self.dims]
    mapping = [sl for sl in self.buffer_mapping]
    cmapping = [sl for sl in self.coord_mapping]
    i = 0
    # refactor this common stuff
    if use_fixed: 
      for _ in range(self.nfixed_front):
        idx = 0
        d,sl = self._convert(idx,i)
        dims[i] = d
        # combine with the original mapping
        replace = mapping[i]
        start = ~replace.start + ~sl.start * ~replace.step
        stop = min(~replace.start + ~sl.stop * ~replace.step, ~replace.stop)
        step = ~replace.step * ~sl.step
        mapping[i] = slice(start, stop, step)         
        replace = cmapping[i]
        start = ~replace.start + ~sl.start * ~replace.step
        stop = min(~replace.start + ~sl.stop * ~replace.step, ~replace.stop)
        step = ~replace.step * ~sl.step
        cmapping[i] = slice(start, stop, step)         
        i += 1      
    for idx in idxs:
      d,sl = self._convert(idx,i)
      dims[i] = d
      # combine with the original mapping
      replace = mapping[i]
      start = ~replace.start + ~sl.start * ~replace.step
      stop = min(~replace.start + ~sl.stop * ~replace.step, ~replace.stop)
      step = ~replace.step * ~sl.step
      mapping[i] = slice(start, stop, step)         
      replace = cmapping[i]
      start = ~replace.start + ~sl.start * ~replace.step
      stop = min(~replace.start + ~sl.stop * ~replace.step, ~replace.stop)
      step = ~replace.step * ~sl.step
      cmapping[i] = slice(start, stop, step)         
      i += 1      
    # refactor this common stuff
    if use_fixed:
      for _ in range(self.nfixed_back):
        idx = 0
        d,sl = self._convert(idx,i)
        dims[i] = d
        # combine with the original mapping
        replace = mapping[i]
        start = ~replace.start + ~sl.start * ~replace.step
        stop = min(~replace.start + ~sl.stop * ~replace.step, ~replace.stop)
        step = ~replace.step * ~sl.step
        mapping[i] = slice(start, stop, step)         
        replace = cmapping[i]
        start = ~replace.start + ~sl.start * ~replace.step
        stop = min(~replace.start + ~sl.stop * ~replace.step, ~replace.stop)
        step = ~replace.step * ~sl.step
        cmapping[i] = slice(start, stop, step)         
        i += 1      

    md = Multidim[T](self.buffer, dims, mapping, cmapping, self.buffer_parent, self.cgrid)
    for b in md.buffer_mapping:
      if ~b.start < 0:
        raise ColaError("Bad idx")
    return md

  ### __CALL__ AND ASSOCIATED FUNCTIONS
  
  # all the calls realized a SINGLE element
  def __call__(self) -> T:
    if self.nunits() != 1:
      raise ColaError('nunits != 1 (= ' + str(self.nunits()))
    coord = self.origin()
    return self.buffer[Multidim.linearize(self.buffer_parent.dims, coord)]      

  def __call__(self, idxs) -> T:
    return self.__getitem__(idxs)()

  def __call__(self, idx0, *idx) -> T:
    tup = (idx0,) + tuple(i for i in idx)
    return self.__getitem__(tup)()

  def _iterate(self):
    return self._iterate([0]*len(self.dims), 0)

  def iterate(self):
    return self._iterate([0]*len(self.dims), 0)
  
  # compute mapping to your parent buffer and directly access. Return linear idx
  def _iterate(self, iterators: list[int], cur_depth: int):
    bmapping = [d for d in self.buffer_mapping]
    buffer_dims = self.buffer_parent.dims
    if cur_depth == len(self.dims) - 1:
      bmap = bmapping[cur_depth]
      for i in range(~bmap.start, ~bmap.stop, ~bmap.step):
        iterators[cur_depth] = i
        linear = Multidim.linearize(buffer_dims, iterators)
        yield linear
    else:
      bmap = bmapping[cur_depth]
      for i in range(~bmap.start, ~bmap.stop, ~bmap.step):
        iterators[cur_depth] = i
        yield from self._iterate(iterators, cur_depth+1)

  def slice_iterate(self):
    return self._slice_iterate([0]*len(self.dims), [0]*len(self.dims), 0)

  def _slice_iterate(self, iterators: list[int], citerators: list[int], cur_depth: int):
    bmapping = [d for d in self.buffer_mapping]
    cmapping = [d for d in self.coord_mapping]
    if cur_depth == len(self.dims) - 1:
      bmap = bmapping[cur_depth]
      cmap = cmapping[cur_depth]
      for i,ic in zip(range(~bmap.start, ~bmap.stop, ~bmap.step),range(~cmap.start, ~cmap.stop, ~cmap.step)):
        iterators[cur_depth] = i        
        citerators[cur_depth] = ic
        yield Multidim(self.buffer, [1]*len(self.dims), [Slice(it,it+1,1) for it in iterators], [Slice(it,it+1,1) for it in citerators], self.buffer_parent, self.cgrid)
        # this is self.buffer_parent.__getitem__ 
        # and not self.__getitem__ bc we are computing everything based
        # on our mapping in buffer_parent
        #yield self.buffer_parent[iterators]
    else:
      bmap = bmapping[cur_depth]
      cmap = cmapping[cur_depth]
      for i,ic in zip(range(~bmap.start, ~bmap.stop, ~bmap.step),range(~cmap.start, ~cmap.stop, ~cmap.step)):
        iterators[cur_depth] = i
        citerators[cur_depth] = ic
        yield from self._slice_iterate(iterators, citerators, cur_depth+1)

  # give 1x1 things
  def __iter__(self) -> Generator[Multidim[T]]:
    return self.slice_iterate()

  # The setitems work by slicing into self with the idxs, and then performing the write
  def __setitem__(self, idx: int, item: T):
    sliced = self[idx]
    sliced._write(item)

  def __setitem__(self, idxs, item):
    sliced = self[idxs]
    sliced._write(item)

  def _write(self, item: T):
    # broadcast it
    for l in self._iterate():
      self.buffer[l] = item

  def _write(self, items: list[T]):
    assert len(items) == self.nunits()
    idx = 0
    for l in self._iterate():
      self.buffer[l] = items[idx]
      idx += 1

  def _write(self, item: Multidim[T]):
    if self.nunits() != item.nunits():
      raise ColaError(str(self.nunits()) + ' ' + str(item.nunits()))
    item_buffer = item.buffer
    for l1,l2 in zip(self._iterate(), item._iterate()):
      self.buffer[l1] = item_buffer[l2]

  def _write(self, item: Block[T]):
    self._write(item.base) 

  def _write(self, item: View[T]):
    self._write(item.base)

  def _str_iterate(self, iterators: list[int], cur_depth: int):
    bmapping = [d for d in self.buffer_mapping]
    buffer_dims = self.buffer_parent.dims
    buffer = self.buffer
    if cur_depth == len(self.dims) - 1:
      cmap = bmapping[cur_depth]
      s = ''
      if cur_depth == 0:
        s += '\n'
      for i in range(~cmap.start, ~cmap.stop, ~cmap.step):
        iterators[cur_depth] = i
        linear = Multidim.linearize(buffer_dims, iterators)
        s += ' ' + str(buffer[linear])
      return s
    else:
      cmap = bmapping[cur_depth]
      s = ''
      for i in range(~cmap.start, ~cmap.stop, ~cmap.step):
        iterators[cur_depth] = i
        if cur_depth == 0 and len(self.dims) > 2:
          s += '\ndims idxs: ' + str(iterators[cur_depth])
        elif cur_depth < (len(self.dims) - 2):
          s += ',' + str(iterators[cur_depth])
        else:
          s += '\n'
        s += self._str_iterate(iterators, cur_depth+1)
      return s
    
  def __str__(self):
    return self._str_iterate(self.origin(), 0)

  def buffer_equals(self, other: list[T]):
    if self.nunits() != len(other):
      return False
    for l1,l2 in zip(self._iterate(), other):
      if self.buffer[l1] != l2:
        return False
    return True

  ### ARITHMETIC

  # broadcast

  def __add__(self, other: T):
    res = Multidim[T](self, True)
    for l0,l1 in zip(res._iterate(), self._iterate()):
      res.buffer[l0] = self.buffer[l1] + other
    return res

  def __radd__(self, other: T):
    res = Multidim[T](self, True)
    for l0,l1 in zip(res._iterate(), self._iterate()):
      res.buffer[l0] = other + self.buffer[l1]
    return res

  def __sub__(self, other: T):
    res = Multidim[T](self, True)
    for l0,l1 in zip(res._iterate(), self._iterate()):
      res.buffer[l0] = self.buffer[l1] - other
    return res

  def __rsub__(self, other: T):
    res = Multidim[T](self, True)
    for l0,l1 in zip(res._iterate(), self._iterate()):
      res.buffer[l0] = other - self.buffer[l1]
    return res

  def __mul__(self, other: T):
    res = Multidim[T](self, True)
    for l0,l1 in zip(res._iterate(), self._iterate()):
      res.buffer[l0] = self.buffer[l1] * other
    return res

  def __rmul__(self, other: T):
    res = Multidim[T](self, True)
    for l0,l1 in zip(res._iterate(), self._iterate()):
      res.buffer[l0] = other * self.buffer[l1]
    return res

  # elementwise

  def __add__(self, other: Multidim[T]):
    res = Multidim[T](self, True)
    for l0,l1,l2 in zip(res._iterate(), self._iterate(), other._iterate()):
      res.buffer[l0] = self.buffer[l1] + other.buffer[l2]
    return res

  def __sub__(self, other: Multidim[T]):
    res = Multidim[T](self, True)
    for l0,l1,l2 in zip(res._iterate(), self._iterate(), other._iterate()):
      res.buffer[l0] = self.buffer[l1] - other.buffer[l2]
    return res


  def __mul__(self, other: Multidim[T]):
    res = Multidim[T](self, True)
    for l0,l1,l2 in zip(res._iterate(), self._iterate(), other._iterate()):
      res.buffer[l0] = self.buffer[l1] * other.buffer[l2]
    return res

    
  # broadcast
#  def __add__(self, other: T) -> Multidim[T]:
#    return Multidim._broadcast_binary_arithmetic(self, other, T.__add__)
#
#  def __radd__(self, other: T) -> Multidim[T]:
#    return Multidim._broadcast_binary_arithmetic(other, self, T.__add__)
#
#  def __sub__(self, other: T) -> Multidim[T]:
#    return Multidim._broadcast_binary_arithmetic(self, other, T.__sub__)
#
#  def __rsub__(self, other: T) -> Multidim[T]:
#    return Multidim._broadcast_binary_arithmetic(other, self, T.__sub__)
#
#  def __mul__(self, other: T) -> Multidim[T]:
#    return Multidim._broadcast_binary_arithmetic(self, other, T.__mul__)
#
#  def __rmul__(self, other: T) -> Multidim[T]:
#    return Multidim._broadcast_binary_arithmetic(other, self, T.__mul__)
#
#  def __truediv__(self, other: T) -> Multidim[float]:
#    return Multidim._broadcast_binary_arithmetic[float](self, other, T.__truediv__)
#
#  def __rtruediv__(self, other: T) -> Multidim[float]:
#    return Multidim._broadcast_binary_arithmetic[float](other, self, T.__truediv__)
#
#  def __floordiv__(self, other: T) -> Multidim[T]:
#    return Multidim._broadcast_binary_arithmetic(self, other, T.__floordiv__)
#
#  def __rfloordiv__(self, other: T) -> Multidim[T]:
#    return Multidim._broadcast_binary_arithmetic(other, self, T.__floordiv__)
#
#  def __rshift__(self, other: T) -> Multidim[T]:
#    return self._broadcast_binary_arithmetic(other, T.__rshift__)
#
#  def __rrshift__(self, other: T) -> Multidim[T]:
#    return self >> other
#
#  def __lshift__(self, other: T) -> Multidim[T]:
#    return self._broadcast_binary_arithmetic(other, T.__lshift__)
#
#  def __rlshift__(self, other: T) -> Multidim[T]:
#    return self << other
#
#  def __lt__(self, other: T) -> Multidim[bool]:
#    return self._broadcast_binary_arithmetic[bool](other, T.__lt__)
#
#  def __le__(self, other: T) -> Multidim[bool]:
#    return self._broadcast_binary_arithmetic[bool](other, T.__le__)
#
#  def __gt__(self, other: T) -> Multidim[bool]:
#    return self._broadcast_binary_arithmetic[bool](other, T.__gt__)
#
#  def __ge__(self, other: T) -> Multidim[bool]:
#    return self._broadcast_binary_arithmetic[bool](other, T.__ge__)
#
#  def __eq__(self, other: T) -> Multidim[bool]:
#    return self._broadcast_binary_arithmetic[bool](other, T.__eq__)
#
#  def __ne__(self, other: T) -> Multidim[bool]:
#    return self._broadcast_binary_arithmetic[bool](other, T.__ne__)
#
  # elementwise

#  def __add__(self, other: Multidim[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other, T.__add__)

#  def __add__(self, other: View[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other.base, T.__add__)

#  def __radd__(self, other: Block[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other.base, T.__add__)

#  def __radd__(self, other: View[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other.base, T.__add__)

#  def __sub__(self, other: Multidim[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other, T.__add__)
#
##  def __sub__(self, other: View[T]) -> Multidim[T]:
##    return self._elementwise_binary_arithmetic(other.base, T.__add__)
#
#  def __mul__(self, other: Block[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other.base, T.__add__)
#
#  def __mul__(self, other: View[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other.base, T.__add__)
#
#  def __truediv__(self, other: Block[T]) -> Multidim[float]:
#    return self._elementwise_binary_arithmetic[float](other.base, T.__truediv__)
#
#  def __truediv__(self, other: View[T]) -> Multidim[float]:
#    return self._elementwise_binary_arithmetic[float](other.base, T.__truediv__)
#
#  def __floordiv__(self, other: Block[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other.base, T.__floordiv__)
#
#  def __floordiv__(self, other: View[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other.base, T.__floordiv__)
#
##  def __rshift__(self, other: Block[T]) -> Multidim[T]:
##    return self._elementwise_binary_arithmetic(other.base, T.__rshift__)
##
#  def __rshift__(self, other: View[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other.base, T.__rshift__)
#
#  def __lshift__(self, other: Block[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other.base, T.__lshift__)
#
#  def __lshift__(self, other: View[T]) -> Multidim[T]:
#    return self._elementwise_binary_arithmetic(other.base, T.__lshift__)
#
#  def __lt__(self, other: Block[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__lt__)
#
#  def __lt__(self, other: View[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__lt__)
#
#  def __le__(self, other: Block[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__le__)
#
#  def __le__(self, other: View[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__le__)
#
#  def __gt__(self, other: Block[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__gt__)
#
#  def __gt__(self, other: View[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__gt__)
#
#  def __ge__(self, other: Block[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__ge__)
#
#  def __ge__(self, other: View[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__ge__)
#
#  def __eq__(self, other: Block[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__eq__)
#
#  def __eq__(self, other: View[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__eq__)
#
#  def __ne__(self, other: Block[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__ne__)
#
#  def __ne__(self, other: View[T]) -> Multidim[bool]:
#    return self._elementwise_binary_arithmetic[bool](other.base, T.__ne__)

# TODO appropriate base data type for buffer (is it a list)?
@extend
class Block[T]:

#  def __init__(self):
#    self.base = Multidim[T](False)

  # need separate init for block and view so it typechecks
  def __init__(self, other: Block[T]):
    self.base = Multidim[T](other, True)

  def __init__(self, other: View[T]):
    self.base = Multidim[T](other, True)

  def __init__(self, other, cgrid: CoordGrid):
    self.base = Multidim[T](other, cgrid)

  def __init__(self, other):
    self.base = Multidim[T](other)

  def __init__(self, dims, data: list[T], cgrid: CoordGrid):
    self.base = Multidim[T](dims, data, cgrid)

  def __init__(self, dims, data: list[T]):
    self.base = Multidim[T](dims, data)

  def __init__(self, cgrid: CoordGrid, dim0: int, dim1: int, *dims):
    self.base = Multidim[T](cgrid, dim0, dim1, *dims)    

  def __init__(self, dim0: int, dim1: int, *dims):
    self.base = Multidim[T](dim0, dim1, *dims)    

  def fix_front(self, amt: int = 1):
    return View(self.base.fix_front(amt))

  def fix_back(self, amt: int = 1):
    return View(self.base.fix_back(amt))

  def dims(self) -> list[int]:
    return self.base.dims

  def dims(self, idx: int) -> int:
    return self.base.dims[idx]

  def nfree_dims(self) -> int:
    return len(self.base.dims) - self.base.nfixed_front - self.base.nfixed_back

  def nunits(self):
    return self.base.nunits()

  # with __setitem__ and __getitem__, we don't need the star arg syntax because args automatically get grouped
  # as a tuple (or just a single item if is a 1D access)
  def __getitem__(self, idx: View[T]) -> View[T]:
    return View[T](self.base[idx.base])

  def __getitem__(self, idx: Block[T]) -> View[T]:
    return View[T](self.base[idx.base])

  def __getitem__(self, idxs) -> View[T]:
    return View[T](self.base[idxs])

  def __setitem__(self, idxs, items):
    self.base[idxs] = items

  # gets a realized (concrete) value
  def __call__(self) -> T:
    return self.base()

  def __call__(self, idx: int) -> T:
    return self.base(idx)

  def __call__(self, idxs) -> T:
    return self.base(idxs)

  def __call__(self, idx0, idx1, *idxs) -> T:
    return self.base(idx0, idx1, *idxs)

  def __str__(self):
    return 'block\n' + str(self.base)

  def __add__(self, other: T):
    return Block(self.base + other)

  def __add__(self, other: Block[T]):
    return Block(self.base + other.base)

  def __add__(self, other: View[T]):
    return Block(self.base + other.base)

  def __radd__(self, other: T):
    return Block(other + self.base)

  def __sub__(self, other: T):
    return Block(self.base - other)

  def __sub__(self, other: Block[T]):
    return Block(self.base - other.base)

  def __sub__(self, other: View[T]):
    return Block(self.base - other.base)

  def __rsub__(self, other: T):
    return Block(other - self.base)

  def __mul__(self, other: T):
    return Block(self.base * other)

  def __mul__(self, other: Block[T]):
    return Block(self.base * other.base)

  def __mul__(self, other: View[T]):
    return Block(self.base * other.base)

  def __rmul__(self, other: T):
    return Block(other * self.base)

  def cgrid(self):
    return self.base.cgrid

#  def __add__(self, other):
#    return Block(self.base + other)
#
#  def __radd__(self, other: T):
#    return Block(self.base.__radd__(other))
#
#  def __radd__(self, other):
#    return Block(other.base.self.base)
#
#  def __sub__(self, other):
#    return Block(self.base - other)
#
#  def __rsub__(self, other: T):
#    return Block(self.base.__rsub__(other))
#
#  def __rsub__(self, other):
#    return Block(other.base.__sub__(self.base))
#
#  def __mul__(self, other):
#    return Block(self.base * other)
#
#  def __rmul__(self, other: T):
#    return Block(self.base.__rmul__(other))
#
#  def __rmul__(self, other):
#    return Block(other.base * self.base)
#
#  def __truediv__(self, other):
#    return Block[float](self.base / other)
#
#  def __rtruediv__(self, other: T):
#    return Block[float](self.base.__rtruediv__(other))
#
#  def __rtruediv__(self, other):
#    return Block[float](other.base / self.base)
#
#  def __floordiv__(self, other):
#    return Block(self.base // other)
#
#  def __rfloordiv__(self, other: T):
#    return Block(self.base.__rfloordiv__(other))
#
#  def __rfloordiv__(self, other):
#    return Block(other.base // self.base)
#
#  def __rshift__(self, other):
#    return Block(self.base >> other)
#
#  def __rrshift__(self, other):
#    return Block(self.base.__rrshift__(other))
#
#  def __lshift__(self, other):
#    return Block(self.base << other)
#
#  def __rlshift__(self, other):
#    return Block(self.base.__rlshift__(other))
#
#  def __lt__(self, other):
#    return Block[bool](self.base < other)
#
#  def __le__(self, other):
#    return Block[bool](self.base <= other)
#
#  def __gt__(self, other):
#    return Block[bool](self.base > other)
#
#  def __ge__(self, other):
#    return Block[bool](self.base >= other)
#
#  def __eq__(self, other):
#    return Block[bool](self.base == other)
#
#  def __ne__(self, other):
#    return Block[bool](self.base != other)

  # iteration, which is just a row-major scan by default
  # yields single view values
  def __iter__(self) -> Generator[View[T]]:
    for item in self.base:
      yield View(item)

  def __bool__(self):
    return bool(self.base)

  def origin(self):
    return self.base.origin()

  def origin_within(self, ancestor):
    return self.base.origin_within(ancestor)

@extend
class View[T]:

#  def __init__(self):
#    self.base = Multidim[T](False)

  # need separate init for block and view so it typechecks
  def __init__(self, parent: Block[T]):
    self.base = Multidim[T](parent, False)

  def __init__(self, parent: View[T]):
    self.base = Multidim[T](parent, False)

  def __init__(self, parent, cgrid: CoordGrid):
    self.base = Multidim[T](parent, cgrid)

  def __init__(self, base: Multidim[T]):
    self.base = base

  def fix_front(self, amt: int = 1):
    return View(self.base.fix_front(amt))

  def fix_back(self, amt: int = 1):
    return View(self.base.fix_back(amt))

  def dims(self) -> list[int]:
    return self.base.dims

  def dims(self, idx: int) -> int:
    return self.base.dims[idx]

  def nfree_dims(self) -> int:
    return len(self.base.dims) - self.base.nfixed_front - self.base.nfixed_back

  def nunits(self):
    return self.base.nunits()

  # with __setitem__ and __getitem__, we don't need the star arg syntax because args automatically get grouped
  # as a tuple (or just a single item if is a 1D access)
  def __getitem__(self, idx: View[T]) -> View[T]:
    return View[T](self.base[idx.base])

  def __getitem__(self, idx: Block[T]) -> View[T]:
    return View[T](self.base[idx.base])

  def __getitem__(self, idxs) -> View[T]:
    return View[T](self.base[idxs])
  
  def __setitem__(self, idxs, items):
    self.base[idxs] = items

  def __str__(self):
    return 'view\n' + str(self.base)

  # gets a realized (concrete) value
  def __call__(self) -> T:
    return self.base()

  def __call__(self, idx: int) -> T:
    return self.base(idx)

  def __call__(self, idxs) -> T:
    return self.base(idxs)

  def __call__(self, idx0, idx1, *idxs) -> T:
    return self.base(idx0, idx1, *idxs)

  def __add__(self, other: T):
    return Block(self.base + other)

  def __add__(self, other: Block[T]):
    return Block(self.base + other.base)

  def __add__(self, other: View[T]):
    return Block(self.base + other.base)

  def __radd__(self, other: T):
    return Block(other + self.base)

  def __sub__(self, other: T):
    return Block[T](self.base - other)

  def __sub__(self, other: Block[T]):
    md: Multidim[T] = self.base - other.base
    return Block[T](md)

  def __sub__(self, other: View[T]):
    return Block(self.base - other.base)

  def __rsub__(self, other: T):
    return Block(other - self.base)

  def __mul__(self, other: T):
    return Block(self.base * other)

  def __mul__(self, other: Block[T]):
    return Block(self.base * other.base)

  def __mul__(self, other: View[T]):
    return Block(self.base * other.base)

  def __rmul__(self, other: T):
    return Block(other * self.base)

  def cgrid(self):
    return self.base.cgrid

#  def __add__(self, other):
#    return Block(self.base + other)
#
#  def __radd__(self, other: T):
#    return Block(self.base.__radd__(other))
#
#  def __radd__(self, other):
#    return Block(other.base + self.base)
#
#  def __sub__(self, other):
#    return Block(self.base - other)
#
#  def __rsub__(self, other: T):
#    return Block(self.base.__rsub__(other))
#
#  def __rsub__(self, other):
#    return Block(other.base - self.base)
#
#  def __mul__(self, other):
#    return Block(self.base * other)
#
#  def __rmul__(self, other: T):
#    return Block(self.base.__rmul__(other))
#
#  def __rmul__(self, other):
#    return Block(other.base * self.base)
#
#  def __truediv__(self, other):
#    return Block[float](self.base / other)
#
#  def __rtruediv__(self, other: T):
#    return Block[float](self.base.__rtruediv__(other))
#
#  def __rtruediv__(self, other):
#    return Block[float](other.base / self.base)
#
#  def __floordiv__(self, other):
#    return Block(self.base // other)
#
#  def __rfloordiv__(self, other: T):
#    return Block(self.base.__rfloordiv__(other))
#
#  def __rfloordiv__(self, other):
#    return Block(other.base // self.base)
#
##  def __rshift__(self, other):
##    return Block(self.base >> other)
##
##  def __rrshift__(self, other):
##    return Block(self.base.__rrshift__(other))
##
##  def __lshift__(self, other):
##    return Block(self.base << other)
##
#  def __rlshift__(self, other):
#    return Block(self.base.__rlshift__(other))
#
#  def __lt__(self, other):
#    return Block[bool](self.base < other)
#
#  def __le__(self, other):
#    return Block[bool](self.base <= other)
#
#  def __gt__(self, other):
#    return Block[bool](self.base > other)
#
#  def __ge__(self, other):
#    return Block[bool](self.base >= other)
#
#  def __eq__(self, other):
#    return Block[bool](self.base == other)
#
#  def __ne__(self, other):
#    return Block[bool](self.base != other)
#
  # iteration, which is just a row-major scan by default
  # yields single view values
  def __iter__(self) -> Generator[View[T]]:
    for item in self.base:
      yield View(item)

  def __bool__(self):
    return bool(self.base)

  def origin(self):
    return self.base.origin()

  def origin_within(self, ancestor):
    return self.base.origin_within(ancestor)

@extend
class File:
  # nelems is total number of elems to read and elem_bytes is the size of each elem
  def read[T](self, nelems: int, elem_bytes: int, block: Block[T]) -> int:
    self._ensure_open();
    assert len(block.base.buffer) >= nelems # make sure enough space
    ret = _C.fread(block.base.buffer.arr.ptr.as_byte(), T.len() // 8, nelems, self.fp)
    self._errcheck("error in read")
    return ret


@extend
class List[T]:
  
  def linearize[S](self,relative_to: Multidim[S]):
    return relative_to.linearize(self)

  def linearize[S](self,relative_to: Block[S]):
    return relative_to.base.linearize(self)

  def linearize[S](self,relative_to: View[S]):
    return relative_to.base.linearize(self)
