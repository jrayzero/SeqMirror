class ExSlice:
  start: Optional[int]
  stop: Optional[int]
  take: Optional[int]
  skip: Optional[int]

  # TODO are there static assertions that I can use for things like in the colaslice.__init__?
  def __init__(self, start: int, stop: int, take: int, skip: int):
    assert start >= 0
    assert stop >= start
    assert take >= 1
    assert skip >= 0
    self.start = start
    self.stop = stop
    self.take = take
    self.skip = skip

  def __init__(self, start: int, stop: int):
    assert start >= 0
    assert stop >= start
    self.start = start
    self.stop = stop
    self.take = 1
    self.skip = 0

  def __init__(self, slc: Slice):
    if slc.start:
      self.start = ~slc.start
      assert ~self.start >= 0
    if slc.stop:
      self.stop = ~slc.stop
      assert ~self.stop >= 0
    if slc.step:
      self.take = 1
      self.skip = ~slc.step - 1
      assert ~self.skip >= 0
    if self.start and self.stop:
      assert ~self.stop >= ~self.start

  def adjust(self, full_length: int):
    start2 = self.start
    stop2 = self.stop
    take2 = self.take
    skip2 = self.skip
    if not start2:
      start2 = 0
    if not stop2:
      assert full_length >= start2
      stop2 = full_length
    if not take2:
      take2 = 1
    if not skip2:
      skip2 = 0
    return ExSlice(start2, stop2, take2, skip2)

  def compute_effective_range(self) -> int:
    assert self.start
    assert self.stop
    assert self.take
    assert self.skip
    full_range = ~self.stop - ~self.start
    full_range_takes = full_range // (~self.take + ~self.skip)
    left_over = full_range % (~self.take + ~self.skip)
    left_over_takes = 1 if left_over >= ~self.take else 0
    all_takes = left_over_takes + full_range_takes
    return all_takes * ~self.take

  # exclusive, as normal stop is
  # this may be different from stop depending on the skip/take (i.e. we may end before than stop)
  def compute_effective_stop(self) -> int:
    return self.compute_effective_range() + ~self.start - 1

  def __str__(self):
    start = str(~self.start) if self.start else "None"
    stop = str(~self.stop) if self.stop else "None"
    take = str(~self.take) if self.take else "None"
    skip = str(~self.skip) if self.skip else "None"
    return '(start: ' + start + ', stop: ' + stop + ', take: ' + take + ', skip: ' + skip + ')'
