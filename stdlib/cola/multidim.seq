from exslice import ExSlice
import string
import random

class Multidim[T]:

  dims: list[int]
  parent_mapping: Optional[list[ExSlice]]
  buffer: Optional[list[T]]
  parent: Optional[Multidim[T]]
  unique_id: str

  def __init__(self, dims: list[int]):
    self.dims = [d for d in dims]
    n = self.nunits()
    self.buffer = [0] * n
#    self.unique_id = ''.join(random.choices(string.printable, k=5))

  def __init__(self, dims: list[int], data: list[T]):
    self.dims = [d for d in dims]
    n = self.nunits()
    assert n == len(data)
    self.buffer = [0] * n    
    # make a deep copy 
    # TODO is data actually pass-by-ref?
    for idx,d in enumerate(data):
      self.buffer[idx] = d      
 #   self.unique_id = ''.join(random.choices(string.printable, k=5))

  def __init__(self, parent: Multidim[T], create_buffer: bool):
    self.parent = parent
    self.dims = [d for d in parent.dims]
    if create_buffer:
      n = 1
      for d in self.dims:
        n *= d
        self.buffer = [T(0)] * n
    self.parent_mapping = []
    for d in self.dims:
      self.parent_mapping.append(ExSlice(0, d, 1, 0))          
 #   self.unique_id = ''.join(random.choices(string.printable, k=5))

  # this is called from the __getitem__ functions, so the ExSlices should already be adjusted
  def __init__(self, parent: Multidim[T], dims: list[int], parent_mapping: list[ExSlice], create_buffer: bool):
    # sanity check
    for pm in parent_mapping:
      assert pm.start
      assert pm.stop
      assert pm.take
      assert pm.skip
    self.parent = parent
    self.dims = dims
    self.parent_mapping = parent_mapping
 #   self.unique_id = ''.join(random.choices(string.printable, k=5))

  # for reshaping (so doesn't have parent_mapping)
  def __init__(self, parent: Multidim[T], dims: list[int]):
    self.parent = parent
    self.dims = dims
    assert self.nunits() == parent.nunits()
 #   self.unique_id = ''.join(random.choices(string.printable, k=5))

  def linearize(self, dims: list[int], coord: list[int]) -> int:
    linear = 0
    for idx,c in enumerate(reversed(coord)):
      s = c
      for i in range(idx):
        s *= dims[len(coord) - i - 1]
      linear += s
    return linear

  def delinearize(self, dims: list[int], linear_idx: int) -> list[int]:
    coord = []
    for idx in range(1, len(dims)):
      mul = 1
      for i in range(idx, len(dims)):
        mul *= dims[i]
      coord.append(linear_idx // mul)
      linear_idx %= mul
    coord.append(linear_idx)
    return coord

  def nunits(self):
    n = 1
    for d in self.dims:
      n *= d
    return n

  # gets local origin relative to parent
  def origin(self) -> list[int]:
    if self.parent_mapping:
      return [~p.start for p in ~self.parent_mapping]
    else:
      return [0] * len(self.dims)

  def abs_origin(self) -> list[int]:
    coord = [0] * len(self.dims)
    _,origin = self._map_to_parent_buffer(coord, False)
    return origin

  # shorthand form of __str__ that just returns size + abs_origin
  def shorthand(self):
    return str(self.dims) + '@' + str(self.abs_origin())

  # This takes a coordinate and remaps it all the way up the chain of parents' until the first buffer is found.
  # Then it linearizes that value. It is the main workhorse of all the other functions
  def _map_to_parent_buffer(self, coord: list[T], linearize_last: bool = True) -> Tuple[list[T], list[int]]:
    assert len(self.dims) == len(coord)
    if self.buffer:
      # Base case. Found the first buffer. Just linearize the coordinate
      if linearize_last:
        return ~self.buffer,[self.linearize(self.dims, coord)] # wrap in list so have consistent return type
      else:
        return ~self.buffer,coord
    else:
      # figure out how to map the current coordinate. There are 2 possibilities:
      # 1) a reshaping: we linearize with respect to ourselves and delinearize wrt the parent
      # 2) a slicing: same ndims, but need to take into account and take/skip values 
      assert self.parent
      if len(coord) != len(self.parent.dims):
        # reshaping
        l = self.linearize(self.dims, coord)
        return self.parent._map_to_parent_buffer(self.delinearize(self.parent.dims, l), linearize_last)
      else:
        # slicing
        new_coord = []  
        for pm,c in zip(self.parent_mapping, coord):
          # NOTE: since these are mapping ExSlices, they should already be adjusted
          start = ~pm.start
          take = ~pm.take
          skip = ~pm.skip
          new_coord.append(start + (c // take) * (take + skip) + c % take)
        return self.parent._map_to_parent_buffer(new_coord, linearize_last)

  def _write(self, idxs, items: list[T]):
    assert self.nunits() == len(items)
    flat = self._flatten()
    for i in range(flat.nunits()):
      buffer,linear = flat._map_to_parent_buffer([i])
      buffer[linear[0]] = items[i]

  def _write(self, idxs, items: Multidim[T]):
    assert self.nunits() == items.nunits()
    self_flat = self._flatten()
    items_flat = items._flatten()
    for i in range(self_flat.nunits()):
      dest_buffer,dest_linear = self_flat._map_to_parent_buffer([i])
      src_buffer,src_linear = items_flat._map_to_parent_buffer([i])
      dest_buffer[dest_linear[0]] = src_buffer[src_linear[0]]

  # The setitems work by slicing into self with the idxs, and then performing the write. This is so we 
  # start off with a simple stride 1 loop nest
  def __setitem__(self, idxs, item: T):
    sliced = self.__getitem__(idxs)    
    sliced._write(idxs, [item])

  def __setitem__(self, idxs, items: list[T]):
    sliced = self.__getitem__(idxs)
    sliced._write(idxs, items)

  def __setitem__(self, idxs, items: Multidim[T]):
    sliced = self.__getitem__(idxs)
    sliced._write(idxs, items)
    
  # produces a slice of self
  def __getitem__(self, idx: int) -> Multidim[T]:    
    assert len(self.dims) == 1
    assert 0 <= idx < self.dims[0]
    return Multidim[T](self, [1], [ExSlice(idx, idx+1, 1, 0)], False)

  def __getitem__(self, idx: Multidim[T]) -> Multidim[T]:
    assert len(self.dims) == 1
    assert idx.nunits() == 1
    val = idx._flatten()(0)
    assert 0 <= val < self.dims[0]
    return Multidim[T](self, [1], [ExSlice(val, val+1, 1, 0)], False)

  def __getitem__(self, idx: ExSlice) -> Multidim[T]:
    assert len(self.dims) == 1
    idx = idx.adjust(self.dims[0])
    assert idx.compute_effective_stop() < self.dims[0]
    return Multidim[T](self, [idx.compute_effective_range()], [idx], False)

  def __getitem__(self, idx: Slice) -> Multidim[T]:
    assert len(self.dims) == 1
    idx2 = ExSlice(idx).adjust(self.dims[0])
    assert idx2.compute_effective_stop() < self.dims[0]
    return Multidim[T](self, [idx2.compute_effective_range()], [idx2], False)

  def __getitem__(self, idxs) -> Multidim[T]:
    assert isinstance(idxs, tuple) or isinstance(idxs, list)
    assert len(self.dims) == len(idxs)
    dims = []
    mapping = []
    i = 0
    for idx in idxs:
      if isinstance(idx, int):
        dims.append(1)
        assert 0 <= idx < self.dims[i]
        mapping.append(ExSlice(idx, idx+1, 1, 0))
      elif isinstance(idx, ExSlice):
        idx = idx.adjust(self.dims[i])
        assert idx.compute_effective_stop() < self.dims[i]
        dims.append(idx.compute_effective_range())
        mapping.append(idx)
      elif isinstance(idx, Slice):
        idx2 = ExSlice(idx).adjust(self.dims[i])
        assert idx2.compute_effective_stop() < self.dims[i]
        dims.append(idx2.compute_effective_range())
        mapping.append(idx2)
      elif isinstance(idx, Multidim[int]):
        assert idx.nunits() == 1
        val = idx._flatten()(0)
        assert 0 <= val < self.dims[i]
        mapping.append(ExSlice(val, val+1, 1, 0))
      else: # a view[int] or block[int], but I can't reference that here
        base: Multidim[int] = idx.base
        assert base.nunits() == 1
        val = base._flatten()(0)
        assert 0 <= val < self.dims[i]
        mapping.append(ExSlice(val, val+1, 1, 0))        
      i += 1
    print(self.unique_id)
    return Multidim[T](self, dims, mapping, False)

  # gets realized values (i.e. not views). Only returns single elements or flat lists
  def _realize(self):
    realized = [0] * self.nunits()
    flat = self._flatten()
    for i in range(flat.nunits()):
      buffer,linear = flat._map_to_parent_buffer([i])
      realized[i] = buffer[linear[0]]
    return realized

  # only using an int index can produce a plain T value b/c otherwise typechecking 
  # can't determine that a slice or ExSlice has range 1 
  # TODO or can it? I can probably add a pass to check that, but I don't know if it 
  # would get past the initial typecheck pass before hitting the IR
  def __call__(self, idx: int) -> T:
    assert len(self.dims) == 1
    buffer,linear = self._map_to_parent_buffer([idx])
    return buffer[linear[0]]

  def __call__(self, idxs) -> list[T]:
    sliced = self.__getitem__(idxs)
    return sliced._realize()

  # reshape but keep same overall nunits
  def reshape(self, new_dims: list[int]):
    return Multidim[T](self, new_dims)

  # reshapes to 1D if needed
  def _flatten(self):
    if len(self.dims) == 1:
      return self
    else:
      return self.reshape([self.nunits()])

  ### Debugging things

  def _get_max_symbol_size(self):
    flat = self._flatten()
    max_size = 0
    for i in range(flat.nunits()):
      buffer,linear = flat._map_to_parent_buffer([i])
      s = str(buffer[linear[0]])
      if len(s) > max_size:
        max_size = len(s)
    return max_size

  # "recursive iteration" to print out 
  def _to_str_loop_nest(self, iterators: list[int], dims: list[int], cur_depth: int, max_sym_size: int) -> str:
    if cur_depth == len(dims) - 1:
      # last level
      s = ''
      if cur_depth == 0:
        s += '\n'
      for i in range(dims[cur_depth]):
        iterators[cur_depth] = i
        buffer,linear = self._map_to_parent_buffer(iterators)
        sym = str(buffer[linear[0]])
        if i == 0:
          s += sym
        else:
          s += ' ' * (max_sym_size - len(sym) + 1) + sym
      return s
    else:      
      # more levels
      s = ''
      for i in range(dims[cur_depth]):
        iterators[cur_depth] = i
        # formatting for printing multiple dimensions
        if cur_depth == 0 and len(dims) > 2:
          s += '\ndim idxs: ' + str(iterators[cur_depth])
        elif cur_depth < len(dims) - 2:
          s += ',' + str(iterators[cur_depth])
        else:
          s += '\n'
        s += self._to_str_loop_nest(iterators, dims, cur_depth+1, max_sym_size)
      return s

  # This uses recursive iteration rather than the flatten because it makes it easier to figure out
  # when to insert the newlines, which depend on which level of the loop nest we are at
  def __str__(self):
    s = ''
    m = self._get_max_symbol_size()
    iterators = [0] * len(self.dims)    
    return self._to_str_loop_nest(iterators, self.dims, 0, m)

  # These do NOT check location information. Just compares contents and possibly the dims
  def buffer_equals(self, that: Multidim[T], compare_ndims: bool) -> bool:
    if self.nunits() != that.nunits():
      return False
    if compare_ndims:
      if len(self.dims) != len(that.dims):
        return False
    self_flat = self._flatten()
    that_flat = that._flatten()
    for i in range(self.nunits()):
      sbuffer,slinear = self_flat._map_to_parent_buffer([i])
      tbuffer,tlinear = that_flat._map_to_parent_buffer([i])
      if sbuffer[slinear[0]] != tbuffer[tlinear[0]]:
        return False
    return True

  def buffer_equals(self, that: list[T]) -> bool:
    if self.nunits() != len(that):
      return False
    flat = self._flatten()
    for i in range(self.nunits()):
      buffer,linear = flat._map_to_parent_buffer([i])
      if buffer[linear[0]] != that[i]:
        return False
    return True

  ### arithmetic
  # All arithmetic is deferred until it is used in a __setitem__ (or wherever else it may
  # be used). This is so that we can support both raw loops and halide style loops where
  # we need to infer a domain. It also should make things less horribly slow, but I'm not
  # gonna bother testing that
  
  def _broadcast_binary_arithmetic(self, other: T, op_func_ptr) -> Multidim[T]:
    flat = self._flatten()
    tmp = Multidim[T](self.dims)    
    for i in range(self.nunits()):
      buffer,linear = flat._map_to_parent_buffer([i])
      tmp.buffer[i] = op_func_ptr(buffer[linear[0]], other)
    return tmp

  def _elementwise_binary_arithmetic(self, other: Multidim[T], op_func_ptr) -> Multidim[T]:
    assert len(self.dims) == len(other.dims)
    assert self.nunits() == other.nunits()
    self_flat = self._flatten()
    other_flat = other._flatten()
    #   if len(self.dims) == 1:
    tmp = Multidim[T](self.dims)
    for i in range(self.nunits()):
      sbuffer,slinear = self_flat._map_to_parent_buffer([i])
      obuffer,olinear = other_flat._map_to_parent_buffer([i])
      tmp.buffer[i] = op_func_ptr(sbuffer[slinear[0]], obuffer[olinear[0]])
    return tmp
    
  # broadcast
  def __add__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__add__)

  def __radd__(self, other: T) -> Multidim[T]:
    return self + other

  def __sub__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__sub__)

  def __rsub__(self, other: T) -> Multidim[T]:
    return self - other

  def __mul__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__mul__)

  def __rmul__(self, other: T) -> Multidim[T]:
    return self * other

  def __truediv__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__truediv__)

  def __rtruediv__(self, other: T) -> Multidim[T]:
    return self / other

  def __floordiv__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__floordiv__)

  def __rfloordiv__(self, other: T) -> Multidim[T]:
    return self // other

  def __rshift__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__rshift__)

  def __rrshift__(self, other: T) -> Multidim[T]:
    return self >> other

  def __lshift__(self, other: T) -> Multidim[T]:
    return self._broadcast_binary_arithmetic(other, T.__lshift__)

  def __rlshift__(self, other: T) -> Multidim[T]:
    return self << other

  # elementwise
  def __add__(self, other: Multidim[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other, T.__add__)

  def __sub__(self, other: Multidim[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other, T.__add__)

  def __mul__(self, other: Multidim[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other, T.__add__)

  def __truediv__(self, other: Multidim[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other, T.__truediv__)

  def __floordiv__(self, other: Multidim[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other, T.__floordiv__)

  def __rshift__(self, other: Multidim[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other, T.__rshift__)

  def __lshift__(self, other: Multidim[T]) -> Multidim[T]:
    return self._elementwise_binary_arithmetic(other, T.__lshift__)

  ### iteration
  def __iter__(self):
    flat = self._flatten()
    for i in range(flat.nunits()):
      yield flat[i]
