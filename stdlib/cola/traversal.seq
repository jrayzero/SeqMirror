class Movement:

  # seek = 0, astep = 1, rstep = 2, arot = 3, rrot = 4
  mtype: int
  angle: Optional[int]
  step: list[int]
  step_multiplier: Optional[int]

  def __init__(self, mtype: int):
    assert mtype == 0 or mtype == 1 or mtype == 2 or mtype == 3 or mtype == 4
    self.mtype = mtype
    self.step = []

  def set_rotation(self, angle: int):
    assert self.is_arot() or self.is_rrot()
    assert angle >= 0
    self.angle = angle

  def set_step(self, step, step_multiplier: int=1):
    assert self.is_seek() or self.is_astep()
    if self.is_seek():
      assert step_multiplier == 1
      for i in step:
        assert i >= 0 # doesn't make sense to seek to a negative position
    self.step = [s for s in step]
    self.step_multiplier = step_multiplier

  def set_step(self, step_multiplier):
    assert self.is_rstep()
    self.step_multiplier = step_multiplier

  def is_seek(self):
    return self.mtype == 0

  def is_astep(self):
    return self.mtype == 1

  def is_rstep(self):
    return self.mtype == 2

  def is_arot(self):
    return self.mtype == 3

  def is_rrot(self):
    return self.mtype == 4

class Traversal:

  movements: list[Movement]

  def __init__(self):
    self.movements = []

  def add_movement(self, movement: Movement):
    self.movements.append(movement)

  def add_seek(self, coord):
    movement = Movement(0)
    movement.set_step(coord)
    self.add_movement(movement)

  def add_astep(self, vec, multiplier=1):
    movement = Movement(1)
    movement.set_step(vec, multiplier)
    self.add_movement(movement)

  def add_rstep(self, multiplier):
    movement = Movement(2)
    movement.set_step(multiplier)
    self.add_movement(movement)

  def add_arot(self, angle):
    movement = Movement(3)
    movement.set_rotation(angle)
    self.add_movement(movement)

  def add_rrot(self, angle):
    movement = Movement(4)
    movement.set_rotation(angle)
    self.add_movement(movement)

  def add_link(self, traversal: Traversal):
    for movement in traversal.movements:
      self.add_movement(movement)

  # iterating through this
  def __iter__(self):
    pass

class AppliedTraversal[T]:
  
  traversal: Traversal
  root: View[T]

  def __init__(self, root: Block[T]):
    self.root = View(root)

  def __init__(self, root: View[T]):
    self.root = root

@extend 
class Traversal:

  def __call__[T](self, root):
    return AppliedTraversal(root)  
