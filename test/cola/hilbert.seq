def build(node, parent_perm=[0,1,2,3]):
  size = node.dims()[0]
  if size == 1:
    return PTree(node)
  else:
    N = size//2
    #  a(0)    b(3)
    #  |       | ==> starting order that we base off of
    #  c(1)----d(2)
    a = node[:N,:N]
    c = node[N:,:N]
    d = node[N:,N:]
    b = node[:N,N:]
    default_quadrants = [a,c,d,b]
    # permute to match the parent
    quadrants = [a,a,a,a]
    for idx,p in enumerate(parent_perm):
      quadrants[idx] = default_quadrants[p]

    # determine the new order for the leftmost and rightmost children
    left_perm = [p for p in parent_perm]
    left_perm[1] = parent_perm[3]
    left_perm[3] = parent_perm[1]

    right_perm = [p for p in parent_perm]
    right_perm[0] = parent_perm[2]
    right_perm[2] = parent_perm[0]
    
    pa = build(quadrants[0], left_perm)
    pc = build(quadrants[1], parent_perm)
    pd = build(quadrants[2], parent_perm)
    pb = build(quadrants[3], right_perm)

    pt = PTree[int](node)
    pt_build pt:
      pt_and:
        pt_leaf pa, pc, pd, pb
    return pt          

print(build(Block[int](1,1)))
print(build(Block[int](2,2)))
print(build(Block[int](4,4)))
print(build(Block[int](8,8)))
print(build(Block[int](16,16)))
