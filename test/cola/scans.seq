from cola.traversal import *
# zigzag

def zz_upper(i):
  trav = Traversal(2)
  trav_build trav:
    if i > 0:
      link zz_upper(i-2)
      astep (0,1), (1,-1) by i-1, (1,0), (-1,1) by i
  return trav

def zz_lower(i):
  trav = Traversal(2)
  trav_build trav:
    if i > 0:
      astep (-1,1) by i, (1,0), (1,-1) by i-1, (0,1) 
      link zz_lower(i-2)
  return trav

def zigzag(N):
  trav = Traversal(2)
  trav_build trav:
    astep (0,0)
    link zz_upper(N-2)
    astep (0,1), (1,-1) by N-1, (0,1)
    link zz_lower(N-2)
  return trav

N = 8
# data ordered such that the zigzag should return a sequential 0,1,2,3,4,...
block = Block[int]([N,N], [0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63])
correct_order = [i for i in range(64)]
zz = zigzag(N)
for z in zz:
  print(z)
print(zz(block))
assert zz(block).trav_equals(correct_order)

# hilbert
def hilbert(i,N,which):
  trav = Traversal(2)
  trav_build trav: 
    if i < N:
      rrot 90 if which else 270
      link hilbert(i+1, N, not which)
      rstep 1
      rrot 270 if which else 90
      link hilbert(i+1, N, which) 
      rstep 1 
      link hilbert(i+1, N, which)
      rrot 270 if which else 90
      rstep 1 
      link hilbert(i+1, N, not which)
      rrot 90 if which else 270
  return trav



# diagonal
#def diag_upper(i):
#  trav = Traversal(2)
#  trav_build trav:
#    if i == 0:
#      astep (1,0)
#    else:
#      astep diag_upper(i-1)
#      astep (i+1,-i)
#      astep (-1,1) by i


#diagonal.axiom([90,ST,A(1,N-1),135,ST])
#diagonal.rule(A(i,j),[225,ST*i,B(i+1,j)],i<N)
#diagonal.rule(B(i,j),[225,SK*(i-1),270,SK*i,A(i,j)],i<N)
#diagonal.rule(A(i,j),[225,ST*(j-1),B(i,j-1)],(i==N)&(j>1))
#diagonal.rule(B(i,j),[225,SK*(j-1),270,SK*j,A(i,j)],(i==N)&(j>1)
